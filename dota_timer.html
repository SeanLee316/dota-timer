<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Dota 2 Таймер - Стиль Игры</title>
    <link rel="manifest" href="manifest.json">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Roboto+Condensed:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        /* --- DOTA 2 THEME STYLES --- */
        :root {
            --d2-bg-dark: #18181b; /* Очень темный фон, почти черный */
            --d2-bg-panel: #22252a; /* Фон панелей, темный серо-синий */
            --d2-bg-panel-light: #2e3238;
            --d2-border-color: #4a505a; /* Цвет рамок */
            --d2-border-highlight: #7a828e;
            --d2-text-primary: #c5c5c5; /* Основной текст, светло-серый */
            --d2-text-secondary: #8b8f98; /* Вторичный текст */
            --d2-text-title: #e0b469; /* Золотистый для заголовков/акцентов */
            --d2-accent-red: #c53630; /* Красный акцент Dota 2 */
            --d2-accent-red-glow: rgba(255, 80, 70, 0.7);
            --d2-accent-blue: #589ad2; /* Синий акцент (Radiant) */
            --d2-accent-green: #70a843; /* Зеленый для позитивных действий */
            --d2-accent-yellow: #f2d06b; /* Желтый для предупреждений */
            --d2-font-title: 'Cinzel', serif;
            --d2-font-body: 'Roboto Condensed', sans-serif;
            --d2-button-bg: linear-gradient(180deg, #3a3f47 0%, #2c3036 100%);
            --d2-button-border: #50555e;
            --d2-button-hover-bg: linear-gradient(180deg, #4a4f57 0%, #3c4046 100%);
            --d2-progress-bar-bg: #1a1c1f;
            --d2-progress-bar-fill: var(--d2-accent-blue);
            --d2-progress-bar-warning-fill: var(--d2-accent-yellow);
            --d2-progress-bar-event-now-fill: var(--d2-accent-red);
        }

        html, body {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; 
            background-color: var(--d2-bg-dark); color: var(--d2-text-primary);
            font-family: var(--d2-font-body);
            font-size: 14px;
            -webkit-tap-highlight-color: transparent;
        }
        .app-wrapper {
            display: flex; flex-direction: column; align-items: center;
            width: 100%; height: 100%; padding: 10px;
            box-sizing: border-box; overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--d2-border-highlight) var(--d2-bg-panel);
        }
        .app-wrapper::-webkit-scrollbar { width: 8px; }
        .app-wrapper::-webkit-scrollbar-track { background: var(--d2-bg-panel); }
        .app-wrapper::-webkit-scrollbar-thumb { background-color: var(--d2-border-highlight); border-radius: 4px; border: 2px solid var(--d2-bg-panel); }

        .main-container {
            display: flex; flex-direction: row; width: 100%;
            max-width: 1400px; /* Немного шире для нового стиля */
            gap: 20px; flex-grow: 1; min-height: 0;
        }
        .left-panel, .right-panel {
            display: flex; flex-direction: column; min-width: 0; overflow: hidden;
            background-color: var(--d2-bg-panel);
            border: 1px solid var(--d2-border-color);
            border-radius: 6px;
            box-shadow: 0 0 15px rgba(0,0,0,0.3), inset 0 0 5px rgba(0,0,0,0.2);
        }
        .left-panel { flex: 2.5; align-items: center; padding: 15px; }
        .right-panel {
            flex: 1.5; padding: 15px; overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--d2-border-highlight) var(--d2-bg-panel-light);
        }
        .right-panel::-webkit-scrollbar { width: 6px; }
        .right-panel::-webkit-scrollbar-track { background: var(--d2-bg-panel-light); }
        .right-panel::-webkit-scrollbar-thumb { background-color: var(--d2-border-highlight); border-radius: 3px; }
        
        #timerDisplay {
            font-family: var(--d2-font-title);
            font-size: 4em; /* Крупнее */
            margin-bottom: 15px; color: var(--d2-text-title);
            font-weight: 700; 
            text-shadow: 0 0 8px var(--d2-text-title), 0 0 12px var(--d2-text-title);
            text-align: center;
            letter-spacing: 1px;
        }
        .controls-column {
            display: flex; flex-direction: column; align-items: stretch; /* Растянуть группы кнопок */
            gap: 10px; margin-bottom: 15px; width: 100%; max-width: 500px;
        }
        .control-group {
            display: flex; align-items: center; gap: 10px;
            background-color: var(--d2-bg-panel-light);
            padding: 10px; border-radius: 4px;
            flex-wrap: wrap; justify-content: center;
            border: 1px solid var(--d2-border-color);
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
        }
        .control-group input[type="number"] {
            width: 50px; padding: 8px; font-size: 1em; text-align: center;
            border: 1px solid var(--d2-border-highlight); background-color: var(--d2-bg-dark); 
            color: var(--d2-text-primary);
            border-radius: 3px; -moz-appearance: textfield;
            font-family: var(--d2-font-body);
        }
        .control-group input[type="number"]::-webkit-outer-spin-button,
        .control-group input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none; margin: 0;
        }
        .control-group span { font-size: 1.2em; color: var(--d2-text-title); }
        .control-group button {
            font-family: var(--d2-font-body);
            font-weight: bold;
            font-size: 0.9em; padding: 8px 15px; cursor: pointer;
            border: 1px solid var(--d2-button-border);
            border-top-color: #60656e; /* Светлее верхняя грань для объема */
            border-radius: 4px; color: var(--d2-text-primary);
            background: var(--d2-button-bg);
            text-shadow: 0 1px 1px rgba(0,0,0,0.5);
            box-shadow: 0 1px 2px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.05);
            transition: all 0.15s ease-out;
            flex-grow: 1; /* Кнопки занимают доступное место в группе */
        }
        .control-group button:hover {
            background: var(--d2-button-hover-bg);
            border-color: var(--d2-border-highlight);
            color: #fff;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.08);
        }
        .control-group button:active {
            transform: translateY(0px);
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.5);
        }
        #lockScreenToggle { background: linear-gradient(180deg, #4a505a 0%, #3c4046 100%); }
        #lockScreenToggle:hover { background: linear-gradient(180deg, #5a606a 0%, #4c5056 100%); }
        .time-sync-controls button { background: linear-gradient(180deg, var(--d2-accent-green) 0%, color-mix(in srgb, var(--d2-accent-green) 70%, black) 100%); }
        .time-sync-controls button:hover { background: linear-gradient(180deg, color-mix(in srgb, var(--d2-accent-green) 120%, white) 0%, var(--d2-accent-green) 100%);}
        .notification-controls button { background: linear-gradient(180deg, var(--d2-accent-yellow) 0%, color-mix(in srgb, var(--d2-accent-yellow) 70%, black) 100%); color: #33280c; }
        .notification-controls button:hover { background: linear-gradient(180deg, color-mix(in srgb, var(--d2-accent-yellow) 120%, white) 0%, var(--d2-accent-yellow) 100%);}
        .gemini-controls button { background: linear-gradient(180deg, #7b1fa2 0%, #5a1879 100%); }
        .gemini-controls button:hover { background: linear-gradient(180deg, #8e24aa 0%, #6a1b9a 100%); }

        .section-title {
            font-family: var(--d2-font-title);
            text-align: center; color: var(--d2-text-title);
            font-size: 1.6em; margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 0 5px var(--d2-text-title);
        }
        #upcomingEvents { width:100%; max-width: 600px; overflow-y: auto; flex-shrink: 1; 
            padding-right: 5px; /* Место для скроллбара */
            scrollbar-width: thin;
            scrollbar-color: var(--d2-border-highlight) var(--d2-bg-panel);
        }
        #upcomingEvents::-webkit-scrollbar { width: 6px; }
        #upcomingEvents::-webkit-scrollbar-track { background: var(--d2-bg-panel); }
        #upcomingEvents::-webkit-scrollbar-thumb { background-color: var(--d2-border-highlight); border-radius: 3px; }

        #upcomingEvents ul, #pastEventsLog ul, #dynamicRecentEventsList ul {
            list-style: none; padding: 0; margin:0;
        }
        #upcomingEvents li, #dynamicRecentEventsList li {
            background-color: var(--d2-bg-panel-light); 
            padding: 10px 12px; margin-bottom: 8px;
            border-radius: 4px; font-size: 1em; 
            border: 1px solid var(--d2-border-color);
            border-left: 4px solid var(--d2-accent-blue);
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
            transition: transform 0.1s ease-out, box-shadow 0.1s ease-out;
        }
        #upcomingEvents li:hover, #dynamicRecentEventsList li:hover {
            transform: translateX(3px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        #pastEventsLog li { 
            background-color: transparent;
            border: none;
            border-bottom: 1px dashed var(--d2-border-color);
            padding: 6px 0; 
            font-size: 0.9em; 
            color: var(--d2-text-secondary);
        }
        #pastEventsLog li:last-child { border-bottom: none; }

        #upcomingEvents li .event-details {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 6px;
        }
        .event-name { font-weight: bold; color: var(--d2-text-primary); }
        .event-time, .log-time { color: var(--d2-text-secondary); font-size:0.9em; }
        .progress-bar-container {
            height: 12px; background-color: var(--d2-progress-bar-bg); border-radius: 6px;
            overflow: hidden; margin-top: 6px;
            border: 1px solid #111;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.4);
        }
        .progress-bar {
            height: 100%; background-color: var(--d2-progress-bar-fill); width: 0%;
            transition: width 0.5s linear;
            box-shadow: inset 0 -1px 1px rgba(0,0,0,0.2), inset 0 1px 1px rgba(255,255,255,0.1);
            border-radius: 5px;
        }
        .alert-warning { border-left-color: var(--d2-accent-yellow) !important; }
        .alert-warning .progress-bar { background-color: var(--d2-progress-bar-warning-fill) !important; }
        .alert-event-now {
            border-left-color: var(--d2-accent-red) !important;
            animation: pulse-border 0.8s infinite alternate;
        }
        .alert-event-now .progress-bar { background-color: var(--d2-progress-bar-event-now-fill) !important; }
        @keyframes pulse-border {
            0% { box-shadow: 0 0 5px var(--d2-accent-red-glow), 0 1px 2px rgba(0,0,0,0.2); }
            100% { box-shadow: 0 0 10px var(--d2-accent-red-glow), 0 0 15px var(--d2-accent-red-glow), 0 1px 2px rgba(0,0,0,0.2); }
        }
        
        .status-messages {
            font-size: 0.85em; color: var(--d2-text-secondary); margin-top: 6px;
            text-align: center; min-height: 1.2em; width: 100%;
            padding: 5px;
            background-color: rgba(0,0,0,0.1);
            border-radius: 3px;
        }
        #dynamicRecentEventsContainer {
            display: none; 
            width: 100%; max-width: 600px; /* Соответствует upcomingEvents */
            margin-top: 15px; padding: 0; /* Убираем внутренний padding, т.к. li его имеют */
            border-radius: 4px; 
            overflow-y: auto; flex-shrink: 0; 
            border: 1px solid var(--d2-border-color);
            background-color: var(--d2-bg-panel);
            padding: 10px;
        }
        #dynamicRecentEventsContainer .section-title { font-size: 1.2em; margin-bottom: 8px; }
        #dynamicRecentEventsList li {
            border-left-color: #ff9800; /* Оранжевый для недавних */
        }
        #dynamicRecentEventsList .event-name { font-weight: normal; }
        #dynamicRecentEventsList .event-meta { font-size: 0.9em; color: var(--d2-text-secondary); }
        #dynamicRecentEventsList .event-timeout { font-size: 0.85em; color: #888; margin-left: 8px;}
        
        .gemini-output {
            margin-top: 15px; padding: 12px; 
            background-color: var(--d2-bg-panel-light); 
            border-radius: 4px; min-height: 3.5em; 
            text-align: left;
            border: 1px solid var(--d2-border-color);
            border-left: 4px solid var(--gemini-button-bg);
            color: var(--d2-text-primary);
            line-height: 1.6;
            width: 100%; max-width: 564px; 
            box-sizing: border-box;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        /* --- АДАПТАЦИЯ (ОБЫЧНЫЙ РЕЖИМ) --- */
        @media (max-width: 768px) and (orientation: portrait) {
            .app-wrapper { padding: 8px; }
            .main-container { flex-direction: column; gap: 12px; }
            .left-panel, .right-panel { flex-basis: auto; width: 100%; padding: 12px; }
            .right-panel { max-height: 35vh; }
            #dynamicRecentEventsContainer { display: none !important; } 
            #timerDisplay { font-size: 3em; }
        }
        @media (max-height: 600px) and (orientation: landscape) and (max-width: 950px) { 
            .app-wrapper { padding: 8px; }
            body:not(.horizontal-lockscreen-mode) { font-size: 13px; }
            .main-container { gap: 10px; }
            .left-panel { flex: 2.8; padding:10px; }
            .right-panel { flex: 2; font-size: 0.85em; padding: 10px; }
            #timerDisplay { font-size: 2.5em; }
            .control-group button { font-size: 0.9em; padding: 6px 10px; }
            .control-group input[type="number"] { width: 40px; padding: 6px; font-size: 0.9em;}
            .section-title { font-size: 1.3em; }
            #upcomingEvents li, #dynamicRecentEventsList li { padding: 8px 10px; font-size: 0.95em; }
            #dynamicRecentEventsContainer { display: block; order: 3; margin-top: 12px; }
            .right-panel { max-height: calc(100vh - 25px); }
        }
        @media (min-width: 769px) and (max-width: 1024px) and (orientation: landscape) {
            body:not(.horizontal-lockscreen-mode) { font-size: 14px; }
            .left-panel { flex: 2.2; }
            .right-panel { flex: 1.8; }
            #dynamicRecentEventsContainer { display: none; } 
        }

        /* --- LOCKSCREEN РЕЖИМ --- */
        body.horizontal-lockscreen-mode { font-size: 16px; background-color: #000; }
        body.horizontal-lockscreen-mode .app-wrapper { padding: 0; overflow: hidden; }
        body.horizontal-lockscreen-mode .main-container {
            flex-direction: column; height: 100%; width: 100%;
            padding: 1.5vh 2.5vw; gap: 1vh; 
            justify-content: space-between; box-sizing: border-box;
        }
        body.horizontal-lockscreen-mode .controls-column,
        body.horizontal-lockscreen-mode .right-panel, 
        body.horizontal-lockscreen-mode #wakeLockStatus,
        body.horizontal-lockscreen-mode #notificationStatus,
        body.horizontal-lockscreen-mode #upcomingEvents > .section-title,
        body.horizontal-lockscreen-mode #lockScreenToggle,
        body.horizontal-lockscreen-mode .gemini-output { 
            display: none !important;
        }
        body.horizontal-lockscreen-mode .left-panel {
            flex: 1; width: 100%; padding:0; border:none; box-shadow:none; background:transparent;
            justify-content: flex-start; align-items: center;
            overflow: hidden; gap: 1.5vh; 
        }
        body.horizontal-lockscreen-mode #timerDisplay {
            font-size: min(8vh, 9vw); 
            line-height: 1; margin-bottom: 1vh; 
            flex-shrink: 0; 
            color: var(--d2-text-title);
            text-shadow: 0 0 10px var(--d2-text-title), 0 0 20px var(--d2-text-title);
        }
        body.horizontal-lockscreen-mode #upcomingEvents {
            width: 100%; max-width: none; flex-grow: 1;
            overflow: hidden; /* Убираем скролл, элементы должны помещаться */
            display: flex; flex-direction: column; justify-content: space-around;
            max-height: 48vh; 
            padding:0; border:none; box-shadow:none; background:transparent;
        }
        body.horizontal-lockscreen-mode #upcomingEvents ul {
            display: flex; flex-direction: column; height: 100%;
            justify-content: space-around; 
        }
        body.horizontal-lockscreen-mode #upcomingEvents li {
            padding: 1.5vh 2vw; font-size: min(3.5vh, 3.3vw); 
            border-left-width: 6px; flex-grow: 1; margin-bottom: 1.2vh; 
            display: flex; flex-direction: column; justify-content: center;
            background-color: rgba(30,30,30,0.85); /* Полупрозрачный фон */
            border: 1px solid rgba(70,70,80,0.7);
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }
        body.horizontal-lockscreen-mode #upcomingEvents li:last-child { margin-bottom: 0; }
        body.horizontal-lockscreen-mode #upcomingEvents li .event-details {
             flex-direction: column; align-items: flex-start; gap: 0.5vh;
        }
        body.horizontal-lockscreen-mode #upcomingEvents li .event-name { font-size: 1em; color: #e5e5e5; }
        body.horizontal-lockscreen-mode #upcomingEvents li .event-time { font-size: 0.75em; color: #a0a0a0; }
        body.horizontal-lockscreen-mode #upcomingEvents li .progress-bar-container {
            height: 2.5vh; border-radius: 1.25vh; margin-top: 1.2vh;
            background-color: #222;
        }
        body.horizontal-lockscreen-mode #dynamicRecentEventsContainer {
            display: block !important; width: 100%;
            padding: 1.5vh 2vw; 
            font-size: min(3.6vh, 3.3vw); 
            background-color: rgba(20,20,20,0.85); 
            border-top: 2px solid rgba(70,70,80,0.7);
            flex-shrink: 0; max-height: 36vh; 
            overflow-y: auto;
            border-radius:0; box-shadow:none;
        }
        body.horizontal-lockscreen-mode #dynamicRecentEventsContainer .section-title {
            display: block; font-size: 0.7em; 
            margin-bottom: 1vh; color: #b0b0b0; text-transform: uppercase;
        }
        body.horizontal-lockscreen-mode #dynamicRecentEventsList li {
            padding: 1.2vh 1.5vw; 
            font-size: 1em; background-color: rgba(40,40,40,0.8); margin-bottom: 1vh;
            border-left-width: 5px;
            border: 1px solid rgba(60,60,70,0.6);
        }
        body.horizontal-lockscreen-mode #dynamicRecentEventsList .event-name { color: #d5d5d5;}
        body.horizontal-lockscreen-mode #dynamicRecentEventsList .event-meta {
            font-size: 0.8em; color: #999;
        }
        body.horizontal-lockscreen-mode #dynamicRecentEventsList .event-timeout { 
            display: inline; font-size: 0.75em; color: #777;
        }
        
        #exitLockScreenButton { 
            display: none; position: fixed; 
            top: 15px; right: 15px; z-index: 20000; 
            padding: 0; 
            background-color: var(--exit-button-bg); color: white; 
            border: 2px solid rgba(255,255,255,0.3); border-radius: 50%; 
            font-size: 1.6em; 
            width: 50px; height: 50px;
            line-height: 48px; text-align: center; /* Скорректировано для центровки */
            box-shadow: 0 0 15px rgba(0,0,0,0.7);
            cursor: pointer;
            user-select: none; 
            opacity: 0.8;
            transition: opacity 0.2s, transform 0.2s;
        }
        #exitLockScreenButton:hover {
            background-color: var(--exit-button-hover-bg);
            opacity: 1;
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <div class="app-wrapper">
        <div class="main-container">
            <div class="left-panel">
                <div id="timerDisplay">00:00</div>
                <div class="controls-column">
                    <div class="control-group time-sync-controls">
                        <input type="number" id="syncMinutes" placeholder="MM" min="0">
                        <span>:</span>
                        <input type="number" id="syncSeconds" placeholder="SS" min="0" max="59">
                        <button id="syncButton">Синхронизировать</button>
                    </div>
                    <div class="control-group main-controls">
                        <button id="startButton">Start Timer</button>
                        <button id="resetButton">Reset Timer</button>
                        <button id="lockScreenToggle">📱 Горизонт. Режим</button>
                    </div>
                    <div class="control-group notification-controls">
                        <button id="toggleNotificationsButton">Включить Уведомления</button>
                    </div>
                    <div class="control-group gemini-controls"> 
                        <button id="geminiTipButton">✨ Дай совет!</button>
                    </div>
                </div>
                 <div id="wakeLockStatus" class="status-messages"></div>
                 <div id="notificationStatus" class="status-messages"></div>
                 <div id="geminiTipDisplay" class="status-messages gemini-output"></div> 
                 <div id="upcomingEvents"> <h2 class="section-title">Ближайшие события</h2>
                    <ul id="eventsList"></ul>
                </div>
                <div id="dynamicRecentEventsContainer">
                    <h2 class="section-title">Недавние Активности</h2>
                    <ul id="dynamicRecentEventsList"></ul>
                </div>
            </div>
            <div class="right-panel">
                <h2 class="section-title">Полный Лог</h2>
                <ul id="pastEventsLogList"></ul>
            </div>
        </div>
    </div>
    <button id="exitLockScreenButton" title="Выйти из полноэкранного режима">✖</button> 


    <audio id="warningSoundPlayer" src="warning_alert.mp3" preload="auto"></audio>
    <audio id="eventNowSoundPlayer" src="event_now_alert.mp3" preload="auto"></audio>

    <script>
        // --- DOM Element References ---
        const timerDisplay = document.getElementById('timerDisplay');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');
        const lockScreenToggleButton = document.getElementById('lockScreenToggle');
        const exitLockScreenButton = document.getElementById('exitLockScreenButton');
        const syncMinutesInput = document.getElementById('syncMinutes');
        const syncSecondsInput = document.getElementById('syncSeconds');
        const syncButton = document.getElementById('syncButton');
        const toggleNotificationsButton = document.getElementById('toggleNotificationsButton');
        const eventsList = document.getElementById('eventsList');
        const dynamicRecentEventsList = document.getElementById('dynamicRecentEventsList');
        const pastEventsLogList = document.getElementById('pastEventsLogList');
        const warningSoundPlayer = document.getElementById('warningSoundPlayer');
        const eventNowSoundPlayer = document.getElementById('eventNowSoundPlayer');
        const wakeLockStatus = document.getElementById('wakeLockStatus');
        const notificationStatus = document.getElementById('notificationStatus');
        const geminiTipButton = document.getElementById('geminiTipButton');
        const geminiTipDisplay = document.getElementById('geminiTipDisplay');

        // --- Constants ---
        const ALERT_OFFSET_SECONDS = 15;
        const PROGRESS_WINDOW_SECONDS = 120;
        const DOTA_ICON_PATH = 'dota_icon.png'; 
        const DYNAMIC_EVENT_LIFETIME_SECONDS = 45; 

        // --- State Variables ---
        let gameTimeInSeconds = 0;
        let timerInterval = null;
        let isTimerRunning = false;
        let eventStates = [];
        let pastEventsLog = [];
        let allPotentiallyRecentEvents = [];
        let wakeLockSentinel = null;
        let popUpNotificationsEnabled = false;

        // --- Screen Wake Lock Functions ---
        const requestWakeLock = async () => {
            if ('wakeLock' in navigator) {
                try {
                    if (wakeLockSentinel) { await wakeLockSentinel.release(); wakeLockSentinel = null; }
                    wakeLockSentinel = await navigator.wakeLock.request('screen');
                    wakeLockStatus.textContent = 'Экран не будет гаснуть.';
                    wakeLockSentinel.addEventListener('release', (event) => { 
                        wakeLockStatus.textContent = '';
                        if (event && event.target === wakeLockSentinel) wakeLockSentinel = null;
                        else if (!event) wakeLockSentinel = null; 
                    });
                } catch (err) {
                    console.error("Wake Lock request error:", err);
                    wakeLockStatus.textContent = 'Не удалось удержать экран.'; wakeLockSentinel = null;
                }
            } else { wakeLockStatus.textContent = 'API удержания экрана не поддерживается.'; }
        };
        const releaseWakeLock = async () => {
            if (wakeLockSentinel) {
                try { await wakeLockSentinel.release(); } catch (err) { console.error("Wake Lock release error:", err); }
                finally { wakeLockSentinel = null; wakeLockStatus.textContent = ''; }
            }
        };
        document.addEventListener('visibilitychange', async () => {
            if (document.visibilityState === 'visible' && isTimerRunning && !wakeLockSentinel) {
                await requestWakeLock();
            }
        });

        // --- Notification Functions ---
        function updateNotificationButtonText() {
            if (Notification.permission === 'denied') {
                toggleNotificationsButton.textContent = 'Уведомления Заблокированы';
                toggleNotificationsButton.disabled = true;
                notificationStatus.textContent = 'Вы заблокировали уведомления для этого сайта.';
            } else if (popUpNotificationsEnabled && Notification.permission === 'granted') {
                toggleNotificationsButton.textContent = 'Выключить Уведомления';
                notificationStatus.textContent = 'Всплывающие уведомления включены.';
            } else {
                toggleNotificationsButton.textContent = 'Включить Уведомления';
                 notificationStatus.textContent = Notification.permission === 'granted' ? 'Всплывающие уведомления выключены.' : 'Разрешите уведомления для сайта.';
            }
        }
        toggleNotificationsButton.addEventListener('click', () => {
            if (Notification.permission === 'denied') { return; }
            if (Notification.permission === 'granted') {
                popUpNotificationsEnabled = !popUpNotificationsEnabled;
                updateNotificationButtonText();
            } else if (Notification.permission === 'default') {
                Notification.requestPermission().then(permission => {
                    if (permission === 'granted') popUpNotificationsEnabled = true;
                    updateNotificationButtonText();
                }).catch(err => { console.error("Notification permission request error:", err); updateNotificationButtonText(); });
            }
        });
        function showBrowserNotification(title, body, tag, requireInteraction = false) {
            let shouldShow = popUpNotificationsEnabled && Notification.permission === 'granted';
            if (shouldShow && !document.body.classList.contains('horizontal-lockscreen-mode') && !document.hasFocus()) {
                shouldShow = false; 
            }
            if (!shouldShow) return;

            const options = { body, icon: DOTA_ICON_PATH, tag, renotify: true, requireInteraction };
            try { new Notification(title, options); } catch (e) { console.error("Error showing notification: ", e); }
        }

        // --- Event Definitions and State Initialization ---
        function getBaseEventDefinitions() {
            const dWS = "warning_alert.mp3"; const dENS = "event_now_alert.mp3";
            return [
                { name: "Начальные Руны Богатства", type: "b_init", spawnTime: 0, isOneTime: true, cat: "rune", ws: dWS, es: dENS },
                { name: "Водные Руны", type: "water", spawnTimes: [120, 240], cat: "rune", ws: dWS, es: dENS },
                { name: "Руны Богатства", type: "bounty", firstSpawn: 180, interval: 180, cat: "rune", ws: dWS, es: dENS },
                { name: "Руны Усиления", type: "power", firstSpawn: 360, interval: 120, cat: "rune", ws: dWS, es: dENS },
                { name: "Руны Мудрости", type: "wisdom", firstSpawn: 420, interval: 420, cat: "rune", ws: dWS, es: dENS },
                { name: "Катапульты", type: "siege", firstSpawn: 300, interval: 150, cat: "creep", ws: dWS, es: dENS },
                { name: "Лотосы", type: "lotus", firstSpawn: 180, interval: 180, cat: "object", ws: dWS, es: dENS },
                { name: "Терзатель", type: "tormentor", spawnTime: 1200, isOneTime: true, cat: "boss", ws: dWS, es: dENS },
                { name: "Ночь", type: "night", firstSpawn: 240, interval: 480, cat: "cycle", ws: dWS, es: dENS },
                { name: "День", type: "day", firstSpawn: 480, interval: 480, cat: "cycle", ws: dWS, es: dENS },
            ];
        }
        function initializeEventStates(currentTime = 0) {
            const baseDefinitions = getBaseEventDefinitions();
            eventStates = baseDefinitions.map(def => {
                const event = { ...def };
                event.warningSound = event.ws; event.eventSound = event.es; 
                if (event.isOneTime) {
                    event.alertedWarning = (currentTime >= event.spawnTime - ALERT_OFFSET_SECONDS && currentTime < event.spawnTime);
                    event.alertedEvent = (currentTime >= event.spawnTime);
                } else if (event.spawnTimes) {
                    event.alertedWarning = event.spawnTimes.map(st => currentTime >= st - ALERT_OFFSET_SECONDS && currentTime < st);
                    event.alertedEvent = event.spawnTimes.map(st => currentTime >= st);
                } else { 
                    event.nextSpawnTime = event.firstSpawn;
                    while (event.nextSpawnTime <= currentTime) { event.nextSpawnTime += event.interval; }
                    event.alertedWarning = (currentTime >= event.nextSpawnTime - ALERT_OFFSET_SECONDS && currentTime < event.nextSpawnTime);
                    event.alertedEvent = false;
                }
                return event;
            });
        }

        // --- Log and Display Functions ---
        function formatTime(totalSeconds) {
            if (isNaN(totalSeconds) || totalSeconds < 0) totalSeconds = 0;
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }
        function updateTimerDisplay() { timerDisplay.textContent = formatTime(gameTimeInSeconds); }
        function playSound(player, eventNameForLog) { 
            if(player && typeof player.play === 'function') {
                player.play().catch(error => console.error(`Audio for ${eventNameForLog}:`, error));
            }
        }
        
        function rebuildPastEventsLog(currentTime) {
            pastEventsLog = [];
            getBaseEventDefinitions().forEach(def => {
                if (def.isOneTime) {
                    if (def.spawnTime <= currentTime) pastEventsLog.push({ name: def.name, time: formatTime(def.spawnTime), rawTime: def.spawnTime });
                } else if (def.spawnTimes) {
                    def.spawnTimes.forEach(st => { if (st <= currentTime) pastEventsLog.push({ name: `${def.name} (${formatTime(st)})`, time: formatTime(st), rawTime: st }); });
                } else {
                    for (let ts = def.firstSpawn; ts <= currentTime; ts += def.interval) pastEventsLog.push({ name: def.name, time: formatTime(ts), rawTime: ts });
                }
            });
            pastEventsLog.sort((a, b) => b.rawTime - a.rawTime);
            if (pastEventsLog.length > 50) pastEventsLog = pastEventsLog.slice(0, 50);
            updatePastEventsLogDisplay();
        }
        function updatePastEventsLogDisplay() {
            pastEventsLogList.innerHTML = pastEventsLog.map(log => `<li><span class="event-name">${log.name}</span> <span class="log-time">(${log.time})</span></li>`).join('');
            if (pastEventsLog.length === 0) pastEventsLogList.innerHTML = '<li>Лог событий пуст.</li>';
        }
        function updateDynamicRecentEventsDisplay() {
            const now = gameTimeInSeconds;
            let recentAndValid = allPotentiallyRecentEvents.filter(event => (event.occurrenceTime + DYNAMIC_EVENT_LIFETIME_SECONDS) > now);
            recentAndValid.sort((a, b) => b.occurrenceTime - a.occurrenceTime);
            const displayItems = recentAndValid.slice(0, 3);

            dynamicRecentEventsList.innerHTML = '';
            const container = document.getElementById('dynamicRecentEventsContainer');
            // Проверяем видимость контейнера не только по style.display, но и по наличию lockscreen класса у body
            const containerVisible = (container && getComputedStyle(container).display !== 'none');


            if (displayItems.length === 0 && containerVisible) {
                 dynamicRecentEventsList.innerHTML = '<li>Нет недавних активностей.</li>';
            } else {
                displayItems.forEach(event => {
                    const timeLeft = Math.max(0, (event.occurrenceTime + DYNAMIC_EVENT_LIFETIME_SECONDS) - now);
                    dynamicRecentEventsList.innerHTML += `<li><span class="event-name">${event.name}</span><span class="event-meta">(${event.timeText}) <span class="event-timeout">Еще ~${timeLeft}с</span></span></li>`;
                });
            }
        }
        function updateUpcomingEventsDisplay(isLockScreen = false) {
            const upcoming = [];
            const displayLimit = gameTimeInSeconds + 15 * 60;
            const maxItems = isLockScreen ? 4 : 7;

            eventStates.forEach(event => {
                if (event.isOneTime && !event.alertedEvent && event.spawnTime > gameTimeInSeconds && event.spawnTime <= displayLimit) {
                    upcoming.push({ name: event.name, time: event.spawnTime, eventObj: event });
                } else if (event.spawnTimes) {
                    event.spawnTimes.forEach((st, idx) => {
                        if (!event.alertedEvent[idx] && st > gameTimeInSeconds && st <= displayLimit) {
                            upcoming.push({ name: event.name, time: st, eventObj: event, spawnIndex: idx });
                        }
                    });
                } else if (!event.isOneTime && !event.spawnTimes && event.nextSpawnTime > gameTimeInSeconds && event.nextSpawnTime <= displayLimit) {
                    upcoming.push({ name: event.name, time: event.nextSpawnTime, eventObj: event });
                }
            });
            upcoming.sort((a, b) => a.time - b.time);
            eventsList.innerHTML = '';
            upcoming.slice(0, maxItems).forEach(e => {
                const timeTo = e.time - gameTimeInSeconds;
                const progressVal = (timeTo <= PROGRESS_WINDOW_SECONDS && timeTo > 0) ? Math.min(100, Math.max(0, ((PROGRESS_WINDOW_SECONDS - timeTo) / PROGRESS_WINDOW_SECONDS) * 100)) : 0;
                const progressHtml = progressVal > 0 ? `<div class="progress-bar-container"><div class="progress-bar" style="width: ${progressVal}%;"></div></div>` : '';
                
                let alertedWarningFlag = false;
                if(e.eventObj.isOneTime) alertedWarningFlag = e.eventObj.alertedWarning;
                else if(e.eventObj.spawnTimes && typeof e.spawnIndex === 'number') alertedWarningFlag = e.eventObj.alertedWarning[e.spawnIndex];
                else if (!e.eventObj.isOneTime && !e.eventObj.spawnTimes) alertedWarningFlag = e.eventObj.alertedWarning;

                const classListVal = timeTo <= 0 && timeTo > -ALERT_OFFSET_SECONDS ? 'alert-event-now' : (alertedWarningFlag && timeTo > 0 && timeTo <= ALERT_OFFSET_SECONDS ? 'alert-warning' : '');
                eventsList.innerHTML += `<li class="${classListVal}"><div class="event-details"><span class="event-name">${e.name}</span><span class="event-time">через ${formatTime(timeTo)} (в ${formatTime(e.time)})</span></div>${progressHtml}</li>`;
            });
            if (upcoming.length === 0 && isTimerRunning) eventsList.innerHTML = '<li>Нет ожидаемых событий.</li>';
            else if (!isTimerRunning && upcoming.length === 0) eventsList.innerHTML = '<li>Запустите или синхронизируйте.</li>';
            else if (!isTimerRunning && gameTimeInSeconds === 0) eventsList.innerHTML = '<li>Таймер не запущен.</li>';
        }
        function updateAllDisplays() {
            updateTimerDisplay();
            updateUpcomingEventsDisplay(document.body.classList.contains('horizontal-lockscreen-mode'));
            updatePastEventsLogDisplay();
            updateDynamicRecentEventsDisplay();
        }

        // --- Core Logic: checkAndTriggerAlerts & mainLoop ---
        function checkAndTriggerAlerts() {
            eventStates.forEach(event => {
                let eventTime, baseName, uniqueIdPart;
                const processEventInstance = (currentTime, alertedWarningFlag, alertedEventFlag, setWarningFlag, setEventFlag, isRepeating = false, advanceRepeatFunc = null) => {
                    if (alertedEventFlag && !isRepeating) return; 
                    if (isRepeating && gameTimeInSeconds < currentTime && alertedEventFlag) return;

                    if (!alertedWarningFlag && gameTimeInSeconds >= currentTime - ALERT_OFFSET_SECONDS && gameTimeInSeconds < currentTime) {
                        playSound(warningSoundPlayer, `${baseName} Warning`);
                        showBrowserNotification(`Предупреждение: ${baseName}`, `Через ${ALERT_OFFSET_SECONDS} сек. (в ${formatTime(currentTime)})`, `d2timer-${event.type}-${uniqueIdPart}-warn`, false);
                        setWarningFlag(true);
                    }
                    if (!alertedEventFlag && gameTimeInSeconds >= currentTime) {
                        playSound(eventNowSoundPlayer, `${baseName} Event Now`);
                        showBrowserNotification(`${baseName} СЕЙЧАС!`, `Событие началось в ${formatTime(currentTime)}`, `d2timer-${event.type}-${uniqueIdPart}-now`, true);
                        
                        const logName = event.spawnTimes ? `${baseName} (${formatTime(currentTime)})` : baseName;
                        if (!pastEventsLog.find(e_1 => e_1.rawTime === currentTime && e_1.name === logName)) {
                             rebuildPastEventsLog(gameTimeInSeconds);
                        }
                        const eventId = `dyn-${event.type}-${uniqueIdPart}`;
                        if (!allPotentiallyRecentEvents.find(e_2 => e_2.id === eventId)) {
                            allPotentiallyRecentEvents.unshift({ id: eventId, name: baseName, timeText: formatTime(currentTime), occurrenceTime: currentTime });
                        }
                        setEventFlag(true); 
                        if (isRepeating && advanceRepeatFunc) advanceRepeatFunc();
                    }
                };

                if (event.isOneTime) {
                    eventTime = event.spawnTime; baseName = event.name; uniqueIdPart = eventTime;
                    processEventInstance(eventTime, event.alertedWarning, event.alertedEvent, (v) => event.alertedWarning = v, (v) => event.alertedEvent = v);
                } else if (event.spawnTimes) {
                    event.spawnTimes.forEach((st, idx) => {
                        eventTime = st; baseName = event.name; uniqueIdPart = st;
                        processEventInstance(eventTime, event.alertedWarning[idx], event.alertedEvent[idx], (v) => event.alertedWarning[idx] = v, (v) => event.alertedEvent[idx] = v);
                    });
                } else { 
                    eventTime = event.nextSpawnTime; baseName = event.name; uniqueIdPart = eventTime; 
                    processEventInstance(eventTime, event.alertedWarning, event.alertedEvent, 
                        (v) => event.alertedWarning = v, 
                        (v) => event.alertedEvent = v, 
                        true, 
                        () => { 
                            const prevNextSpawn = event.nextSpawnTime;
                            while (event.nextSpawnTime <= gameTimeInSeconds) {
                                event.nextSpawnTime += event.interval;
                            }
                            if (event.nextSpawnTime > prevNextSpawn) { 
                                event.alertedWarning = false; 
                                event.alertedEvent = false;
                            }
                        }
                    );
                }
            });
            if (allPotentiallyRecentEvents.length > 20) allPotentiallyRecentEvents = allPotentiallyRecentEvents.slice(0, 20);
            updateAllDisplays();
        }
        function mainLoop() {
            if (!isTimerRunning) return;
            gameTimeInSeconds++;
            checkAndTriggerAlerts();
        }

        // --- LockScreen Mode Logic ---
        async function enterLockScreenMode() {
            document.body.classList.add('horizontal-lockscreen-mode');
            document.querySelector('.app-wrapper').scrollTop = 0;
            lockScreenToggleButton.textContent = 'Выйти';
            exitLockScreenButton.style.display = 'block';
            if (document.documentElement.requestFullscreen) {
                try { await document.documentElement.requestFullscreen(); } catch (err) { console.warn("FS fail:",err.message); }
            }
            if (screen.orientation && screen.orientation.lock) {
                try { await screen.orientation.lock('landscape-primary'); } catch (err) { 
                    try { await screen.orientation.lock('landscape'); } 
                    catch (err2) { console.warn("Orient. lock fail:",err2.message); }
                }
            }
            if (isTimerRunning && !wakeLockSentinel) await requestWakeLock();
            updateAllDisplays();
        }
        async function exitLockScreenMode() {
            document.body.classList.remove('horizontal-lockscreen-mode');
            lockScreenToggleButton.textContent = '📱 Горизонт. Режим';
            exitLockScreenButton.style.display = 'none';
            if (document.fullscreenElement && document.exitFullscreen) {
                try { await document.exitFullscreen(); } catch (err) { console.warn("Exit FS fail:",err.message); }
            }
            if (screen.orientation && screen.orientation.unlock) {
                try { screen.orientation.unlock(); } catch (err) { console.warn("Orient. unlock fail:",err.message); }
            }
            updateAllDisplays();
        }
        lockScreenToggleButton.addEventListener('click', () => {
            if (document.body.classList.contains('horizontal-lockscreen-mode')) exitLockScreenMode();
            else enterLockScreenMode();
        });
        exitLockScreenButton.addEventListener('click', exitLockScreenMode);
        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement && document.body.classList.contains('horizontal-lockscreen-mode')) {
                exitLockScreenMode();
            }
        });
        
        // --- Gemini API Integration ---
        geminiTipButton.addEventListener('click', async () => {
            if (!isTimerRunning && gameTimeInSeconds === 0) {
                geminiTipDisplay.textContent = "Запустите таймер, чтобы получить совет, актуальный для текущего времени игры.";
                return;
            }
            geminiTipDisplay.innerHTML = "✨ Получение совета от Gemini..."; 

            const gameMinutes = Math.floor(gameTimeInSeconds / 60);
            const prompt = `Dota 2: Сейчас ${gameMinutes} минута игры. Дай краткий и полезный совет (1-2 предложения) для игрока в типичном публичном матче на этой стадии игры. Отвечай на русском языке.`;
            
            let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
            const payload = { contents: chatHistory };
            const apiKey = ""; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("Gemini API error response:", errorData);
                    throw new Error(`Ошибка от Gemini API: ${response.status} ${response.statusText}. ${errorData?.error?.message || ''}`);
                }

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    geminiTipDisplay.textContent = text;
                } else {
                    console.error("Unexpected response structure from Gemini API:", result);
                    geminiTipDisplay.textContent = "Не удалось получить совет. Попробуйте позже.";
                }
            } catch (error) {
                console.error('Ошибка при запросе к Gemini API:', error);
                geminiTipDisplay.textContent = `Произошла ошибка: ${error.message}. Попробуйте позже.`;
            }
        });


        // --- Event Listeners for Controls ---
        function attemptInitialSoundUnlock() {
            const p1 = warningSoundPlayer.play(); if (p1 && p1.then) p1.then(_=>warningSoundPlayer.pause()).catch(()=>{});
            const p2 = eventNowSoundPlayer.play(); if (p2 && p2.then) p2.then(_=>eventNowSoundPlayer.pause()).catch(()=>{});
        }
        startButton.addEventListener('click', async () => {
            attemptInitialSoundUnlock();
            if (!isTimerRunning) {
                isTimerRunning = true;
                await requestWakeLock();
                if (gameTimeInSeconds === 0 && pastEventsLog.length === 0) { 
                    initializeEventStates(0); rebuildPastEventsLog(0); allPotentiallyRecentEvents = [];
                }
                updateAllDisplays(); 
                if(timerInterval) clearInterval(timerInterval); 
                timerInterval = setInterval(mainLoop, 1000);
                startButton.textContent = "Pause Timer";
            } else {
                isTimerRunning = false;
                await releaseWakeLock();
                clearInterval(timerInterval);
                timerInterval = null; 
                startButton.textContent = "Resume Timer";
            }
        });
        resetButton.addEventListener('click', async () => {
            attemptInitialSoundUnlock();
            isTimerRunning = false; await releaseWakeLock(); 
            if(timerInterval) clearInterval(timerInterval); timerInterval = null;
            gameTimeInSeconds = 0;
            syncMinutesInput.value = ''; syncSecondsInput.value = '';
            initializeEventStates(0); rebuildPastEventsLog(0); allPotentiallyRecentEvents = [];
            geminiTipDisplay.textContent = ""; 
            updateAllDisplays();
            startButton.textContent = "Start Timer";
        });
        syncButton.addEventListener('click', async () => {
            attemptInitialSoundUnlock();
            let wasRunning = isTimerRunning;
            if (isTimerRunning) { isTimerRunning = false; clearInterval(timerInterval); timerInterval = null; }
            
            const minutesText = syncMinutesInput.value;
            const secondsText = syncSecondsInput.value;
            const minutes = minutesText === "" ? 0 : parseInt(minutesText);
            const seconds = secondsText === "" ? 0 : parseInt(secondsText);

            if (isNaN(minutes) || isNaN(seconds) || minutes < 0 || seconds < 0 || seconds > 59) {
                alert("Пожалуйста, введите корректное время (минуты >= 0, секунды 0-59).");
                if (wasRunning) { 
                    isTimerRunning = true; 
                    if(timerInterval) clearInterval(timerInterval);
                    timerInterval = setInterval(mainLoop, 1000); 
                }
                return;
            }
            await releaseWakeLock(); 
            gameTimeInSeconds = (minutes * 60) + seconds;
            initializeEventStates(gameTimeInSeconds);
            rebuildPastEventsLog(gameTimeInSeconds);
            allPotentiallyRecentEvents = []; 
            getBaseEventDefinitions().forEach(def => {
                const addRecent = (ts, name, type) => {
                    if (ts <= gameTimeInSeconds && ts + DYNAMIC_EVENT_LIFETIME_SECONDS > gameTimeInSeconds) {
                        allPotentiallyRecentEvents.unshift({ id: `dyn-${type}-${ts}`, name, timeText: formatTime(ts), occurrenceTime: ts });
                    }
                };
                if (def.isOneTime) addRecent(def.spawnTime, def.name, def.type);
                else if (def.spawnTimes) def.spawnTimes.forEach(st => addRecent(st, def.name, def.type));
                else for (let ts = def.firstSpawn; ts <= gameTimeInSeconds; ts += def.interval) addRecent(ts, def.name, def.type);
            });
            allPotentiallyRecentEvents.sort((a,b) => b.occurrenceTime - a.occurrenceTime);
            if(allPotentiallyRecentEvents.length > 20) allPotentiallyRecentEvents = allPotentiallyRecentEvents.slice(0,20);
            geminiTipDisplay.textContent = ""; 
            updateAllDisplays();
            startButton.textContent = "Resume Timer";
        });

        // --- Service Worker Registration ---
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js') 
                    .then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(error => {
                        console.log('ServiceWorker registration failed: ', error);
                    });
            });
        }
        
        // --- Initial Page Load ---
        initializeEventStates(0);
        updateAllDisplays();
        updateNotificationButtonText();
    </script>
</body>
</html>
