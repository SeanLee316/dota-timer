<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dota 2 Таймер Событий v6 (Adaptive Landscape)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 10px; /* Уменьшим общий padding для экономии места */
            background-color: #1e1e1e;
            color: #e0e0e0;
            font-size: 14px;
        }
        .main-container {
            display: flex;
            flex-direction: row; /* По умолчанию панели рядом */
            width: 100%;
            max-width: 1300px; /* Немного увеличим для десктопов */
            gap: 15px; /* Уменьшим gap */
        }
        .left-panel {
            flex: 2.5; /* Больше места для основного контента */
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 0; /* Для корректного сжатия flex-элементов */
        }
        .right-panel {
            flex: 1.5; /* Место для лога */
            background-color: #2a2a2a;
            padding: 10px 12px;
            border-radius: 8px;
            max-height: calc(100vh - 40px); /* Адаптивная высота для лога */
            overflow-y: auto;
            min-width: 0;
        }
        #timerDisplay {
            font-size: 3.2em; /* Немного уменьшим для общих случаев */
            margin-bottom: 8px;
            color: #00aeff;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0,174,255,0.5);
        }
        .controls-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            width: 100%; /* Чтобы занимало всю ширину левой панели */
        }
        .time-sync-controls, .main-controls, .notification-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            background-color: #2a2a2a;
            padding: 8px; /* Уменьшим padding */
            border-radius: 5px;
            flex-wrap: wrap;
            justify-content: center;
            width: calc(100% - 16px); /* С учетом padding */
            box-sizing: border-box;
        }
        .time-sync-controls input[type="number"] {
            width: 45px; /* Уменьшим */
            padding: 7px;
            font-size: 0.95em;
            text-align: center;
            border: 1px solid #444;
            background-color: #333;
            color: #e0e0e0;
            border-radius: 3px;
            -moz-appearance: textfield;
        }
        .time-sync-controls input[type="number"]::-webkit-outer-spin-button,
        .time-sync-controls input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none; margin: 0;
        }
        .time-sync-controls span { font-size: 1.1em; color: #00aeff; }

        .controls button, .time-sync-controls button, .notification-controls button {
            font-size: 0.95em; /* Немного меньше */
            padding: 7px 12px;
            cursor: pointer; border: none; border-radius: 5px;
            background-color: #00aeff; color: #ffffff;
            transition: background-color 0.2s ease-in-out;
        }
        .time-sync-controls button { background-color: #5cb85c; }
        .notification-controls button { background-color: #ffc107; color: #1e1e1e; }
        .controls button:hover { background-color: #007acc; }
        .time-sync-controls button:hover { background-color: #4cae4c; }
        .notification-controls button:hover { background-color: #e0a800; }

        .section-title {
            text-align: center; color: #00aeff;
            font-size: 1.4em; margin-bottom: 8px;
        }
        #upcomingEvents { width:100%; }
        #upcomingEvents ul, #pastEventsLog ul, #dynamicRecentEventsList ul {
            list-style: none; padding: 0; margin:0;
        }
        #upcomingEvents li, #pastEventsLog li, #dynamicRecentEventsList li {
            background-color: #333333;
            padding: 8px 10px; /* Уменьшим padding */
            margin-bottom: 6px;
            border-radius: 4px;
            font-size: 1em; /* Базовый для элементов списка */
            border-left: 3px solid #00aeff;
        }
        #pastEventsLog li { border-left-color: #4caf50; font-size: 0.9em; }
        #upcomingEvents li .event-details {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 4px;
        }
        .event-name { font-weight: bold; }
        .event-time, .log-time { color: #b0b0b0; font-size:0.95em; }
        .progress-bar-container {
            height: 7px; background-color: #555; border-radius: 3px;
            overflow: hidden; margin-top: 4px;
        }
        .progress-bar {
            height: 100%; background-color: #00aeff; width: 0%;
            transition: width 0.5s linear;
        }
        .alert-warning { border-left-color: #ffc107 !important; }
        .alert-event-now {
            border-left-color: #dc3545 !important;
            animation: pulse 0.8s infinite alternate;
        }
        @keyframes pulse {
            0% { background-color: rgba(220, 53, 69, 0.4); }
            100% { background-color: rgba(220, 53, 69, 0.15); }
        }
        .right-panel::-webkit-scrollbar { width: 6px; }
        .right-panel::-webkit-scrollbar-track { background: #2a2a2a; border-radius: 6px; }
        .right-panel::-webkit-scrollbar-thumb { background: #555; border-radius: 6px; }
        .right-panel::-webkit-scrollbar-thumb:hover { background: #777; }

        .status-messages {
            font-size: 0.8em; color: #aaa; margin-top: 4px;
            text-align: center; min-height: 1em; width: 100%;
        }
        
        /* Dynamic Recent Events Strip */
        #dynamicRecentEventsContainer {
            display: none; /* Скрыт по умолчанию, будет показан через JS/CSS для landscape */
            width: calc(100% - 16px); /* С учетом padding родителя, если он есть */
            margin-top: 10px;
            padding: 8px;
            background-color: #272729; /* Немного другой фон */
            border-radius: 5px;
            box-sizing: border-box;
        }
        #dynamicRecentEventsContainer .section-title { font-size: 1.1em; margin-bottom: 6px; }
        #dynamicRecentEventsList li {
            background-color: #38383a;
            padding: 6px 8px;
            font-size: 0.9em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-left: 3px solid #ff9800; /* Оранжевый акцент для недавних */
        }
        #dynamicRecentEventsList .event-name { font-weight: normal; }
        #dynamicRecentEventsList .event-meta { font-size: 0.85em; color: #c0c0c0; }
        #dynamicRecentEventsList .event-timeout { font-size: 0.8em; color: #999; margin-left: 8px;}


        /* --- Адаптация --- */
        /* Портретный режим для телефонов и маленьких планшетов */
        @media (max-width: 768px) and (orientation: portrait) {
            .main-container { flex-direction: column; }
            .left-panel, .right-panel { flex-basis: auto; width: 100%; }
            .right-panel { max-height: 30vh; /* Меньше высота для лога в портрете */ }
            #dynamicRecentEventsContainer { display: none !important; } /* Не нужен, т.к. лог и так ниже*/
        }

        /* Горизонтальный режим для телефонов (основные изменения здесь) */
        @media (max-height: 550px) and (orientation: landscape) {
            body { font-size: 12.5px; padding: 8px; } /* Уменьшаем шрифт и отступы */
            .main-container { gap: 10px; }
            .left-panel { flex: 3; } /* Больше места таймеру и контролам */
            .right-panel { 
                flex: 2; /* Лог тоже важен */
                font-size: 0.8em; /* Мелкий шрифт в логе */
                padding: 8px;
            }
            #timerDisplay { font-size: 2.5em; } /* Компактнее таймер */
            .controls button, .time-sync-controls button, .notification-controls button {
                font-size: 0.85em; padding: 5px 8px; margin: 3px;
            }
            .time-sync-controls input[type="number"] { width: 38px; padding: 5px; font-size: 0.85em;}
            .section-title { font-size: 1.2em; }
            #upcomingEvents li { padding: 6px 8px; font-size: 0.95em; }
            #dynamicRecentEventsContainer { display: block; } /* Показываем блок недавних событий */
             .right-panel { max-height: calc(100vh - 20px); } /* Лог занимает всю доступную высоту */
        }
        
        /* Планшеты в горизонтальном режиме (могут использовать десктопный вид или иметь свои настройки) */
        @media (min-width: 769px) and (max-width: 1024px) and (orientation: landscape) {
            body { font-size: 13.5px; }
            .left-panel { flex: 2.2; }
            .right-panel { flex: 1.8; }
            #dynamicRecentEventsContainer { display: none; } /* Для планшетов полный лог предпочтительнее */
        }

    </style>
</head>
<body>
    <div class="main-container">
        <div class="left-panel">
            <div id="timerDisplay">00:00</div>
            <div class="controls-column">
                <div class="time-sync-controls">
                    <input type="number" id="syncMinutes" placeholder="MM" min="0">
                    <span>:</span>
                    <input type="number" id="syncSeconds" placeholder="SS" min="0" max="59">
                    <button id="syncButton">Синхронизировать</button>
                </div>
                <div class="main-controls">
                    <button id="startButton">Start Timer</button>
                    <button id="resetButton">Reset Timer</button>
                </div>
                <div class="notification-controls">
                    <button id="toggleNotificationsButton">Включить Уведомления</button>
                </div>
            </div>
             <div id="wakeLockStatus" class="status-messages"></div>
             <div id="notificationStatus" class="status-messages"></div>

            <div id="upcomingEvents" style="width:100%; max-width:600px;">
                <h2 class="section-title">Ближайшие события</h2>
                <ul id="eventsList"></ul>
            </div>
             <div id="dynamicRecentEventsContainer">
                <h2 class="section-title">Недавние Активности</h2>
                <ul id="dynamicRecentEventsList"></ul>
            </div>
        </div>
        <div class="right-panel">
            <h2 class="section-title">Полный Лог</h2>
            <ul id="pastEventsLogList"></ul>
        </div>
    </div>

    <audio id="warningSoundPlayer" src="warning_alert.mp3" preload="auto"></audio>
    <audio id="eventNowSoundPlayer" src="event_now_alert.mp3" preload="auto"></audio>

    <script>
        const timerDisplay = document.getElementById('timerDisplay');
        const startButton = document.getElementById('startButton');
        // ... (остальные const объявления как в v5) ...
        const toggleNotificationsButton = document.getElementById('toggleNotificationsButton');
        const wakeLockStatus = document.getElementById('wakeLockStatus');
        const notificationStatus = document.getElementById('notificationStatus');
        const dynamicRecentEventsList = document.getElementById('dynamicRecentEventsList');


        const syncMinutesInput = document.getElementById('syncMinutes');
        const syncSecondsInput = document.getElementById('syncSeconds');
        const syncButton = document.getElementById('syncButton');
        // Инициализация остальных DOM элементов как в предыдущей версии
        const eventsList = document.getElementById('eventsList');
        const pastEventsLogList = document.getElementById('pastEventsLogList');
        const warningSoundPlayer = document.getElementById('warningSoundPlayer');
        const eventNowSoundPlayer = document.getElementById('eventNowSoundPlayer');


        const ALERT_OFFSET_SECONDS = 15;
        const PROGRESS_WINDOW_SECONDS = 120;
        const DOTA_ICON_PATH = 'dota_icon.png'; 
        const DYNAMIC_EVENT_LIFETIME_SECONDS = 30; // Сколько секунд событие будет в динамическом списке

        let gameTimeInSeconds = 0;
        let timerInterval = null;
        let isTimerRunning = false;
        let eventStates = [];
        let pastEventsLog = []; // Для полного лога
        let allPotentiallyRecentEvents = []; // Для динамического списка последних событий
        
        let wakeLockSentinel = null; 
        let popUpNotificationsEnabled = false;

        // --- Dynamic Recent Events Functions ---
        function updateDynamicRecentEventsDisplay() {
            const now = gameTimeInSeconds;
            // Фильтруем события: оставляем те, что произошли не более DYNAMIC_EVENT_LIFETIME_SECONDS назад
            let recentAndValid = allPotentiallyRecentEvents.filter(event => (event.occurrenceTime + DYNAMIC_EVENT_LIFETIME_SECONDS) > now);
            
            // Сортируем по времени наступления (самые новые в начале)
            recentAndValid.sort((a, b) => b.occurrenceTime - a.occurrenceTime);

            // Берем топ 3
            const displayItems = recentAndValid.slice(0, 3);

            dynamicRecentEventsList.innerHTML = ''; // Очищаем список
            if (displayItems.length === 0 && document.getElementById('dynamicRecentEventsContainer').style.display === 'block') {
                 dynamicRecentEventsList.innerHTML = '<li>Нет недавних активностей.</li>';
            } else {
                displayItems.forEach(event => {
                    const listItem = document.createElement('li');
                    const timeLeftForDisplay = Math.max(0, (event.occurrenceTime + DYNAMIC_EVENT_LIFETIME_SECONDS) - now);
                    listItem.innerHTML = `
                        <span class="event-name">${event.name}</span>
                        <span class="event-meta">(${event.timeText}) <span class="event-timeout">Еще ~${timeLeftForDisplay}с</span></span>
                    `;
                    dynamicRecentEventsList.appendChild(listItem);
                });
            }
        }
        // --- End Dynamic Recent Events Functions ---

        // --- Notification Functions ---
        function updateNotificationButtonText() {
            if (Notification.permission === 'denied') {
                toggleNotificationsButton.textContent = 'Уведомления Заблокированы';
                toggleNotificationsButton.disabled = true;
                notificationStatus.textContent = 'Вы заблокировали уведомления для этого сайта.';
            } else if (popUpNotificationsEnabled && Notification.permission === 'granted') {
                toggleNotificationsButton.textContent = 'Выключить Уведомления';
                notificationStatus.textContent = 'Всплывающие уведомления включены.';
            } else {
                toggleNotificationsButton.textContent = 'Включить Уведомления';
                 notificationStatus.textContent = Notification.permission === 'granted' ? 'Всплывающие уведомления выключены.' : 'Разрешите уведомления для сайта.';
            }
        }

        toggleNotificationsButton.addEventListener('click', () => {
            if (Notification.permission === 'denied') {
                alert('Уведомления заблокированы в настройках вашего браузера для этого сайта.');
                return;
            }
            if (Notification.permission === 'granted') {
                popUpNotificationsEnabled = !popUpNotificationsEnabled;
                updateNotificationButtonText();
            } else if (Notification.permission === 'default') {
                Notification.requestPermission().then(permission => {
                    if (permission === 'granted') {
                        popUpNotificationsEnabled = true;
                    }
                    updateNotificationButtonText();
                });
            }
        });

        function showBrowserNotification(title, body, tag, requireInteraction = false) {
            if (!popUpNotificationsEnabled || Notification.permission !== 'granted' || !document.hasFocus()) {
                return;
            }
            const options = { body, icon: DOTA_ICON_PATH, tag, renotify: true, requireInteraction };
            try { new Notification(title, options); } catch (e) { console.error("Error showing notification: ", e); }
        }
        // --- End Notification Functions ---

        // --- Screen Wake Lock Functions (без изменений от v4) ---
        const requestWakeLock = async () => {
            if ('wakeLock' in navigator) {
                try {
                    if (wakeLockSentinel) { await wakeLockSentinel.release(); wakeLockSentinel = null; }
                    wakeLockSentinel = await navigator.wakeLock.request('screen');
                    wakeLockStatus.textContent = 'Экран не будет гаснуть.';
                    wakeLockSentinel.addEventListener('release', () => {
                        wakeLockStatus.textContent = '';
                        if (event.target === wakeLockSentinel) wakeLockSentinel = null;
                    });
                } catch (err) {
                    wakeLockStatus.textContent = 'Не удалось удержать экран.'; wakeLockSentinel = null;
                }
            } else { wakeLockStatus.textContent = 'API удержания экрана не поддерживается.'; }
        };
        const releaseWakeLock = async () => {
            if (wakeLockSentinel) {
                try { await wakeLockSentinel.release(); } catch (err) { /*ignore*/ }
                finally { wakeLockSentinel = null; wakeLockStatus.textContent = ''; }
            }
        };
        document.addEventListener('visibilitychange', async () => {
            if (document.visibilityState === 'visible' && isTimerRunning && !wakeLockSentinel) {
                await requestWakeLock();
            }
        });
        // --- End Screen Wake Lock Functions ---

        function getBaseEventDefinitions() { // Без изменений
            const defaultWarningSound = "warning_alert.mp3";
            const defaultEventNowSound = "event_now_alert.mp3";
            return [
                { name: "Начальные Руны Богатства", type: "bounty_initial", spawnTime: 0, isOneTime: true, category: "rune", warningSound: defaultWarningSound, eventSound: defaultEventNowSound },
                { name: "Водные Руны", type: "water_runes", spawnTimes: [2 * 60, 4 * 60], category: "rune", warningSound: defaultWarningSound, eventSound: defaultEventNowSound },
                { name: "Руны Богатства", type: "bounty_repeating", firstSpawn: 3 * 60, interval: 3 * 60, category: "rune", warningSound: defaultWarningSound, eventSound: defaultEventNowSound },
                { name: "Руны Усиления", type: "power_runes", firstSpawn: 6 * 60, interval: 2 * 60, category: "rune", warningSound: defaultWarningSound, eventSound: defaultEventNowSound },
                { name: "Руны Мудрости", type: "wisdom_runes", firstSpawn: 7 * 60, interval: 7 * 60, category: "rune", warningSound: defaultWarningSound, eventSound: defaultEventNowSound },
                { name: "Катапульты", type: "siege_creeps", firstSpawn: 5 * 60, interval: 2.5 * 60, category: "creep", warningSound: defaultWarningSound, eventSound: defaultEventNowSound },
                { name: "Лотосы", type: "lotus_pool", firstSpawn: 3 * 60, interval: 3 * 60, category: "object", warningSound: defaultWarningSound, eventSound: defaultEventNowSound },
                { name: "Терзатель (первый)", type: "tormentor", spawnTime: 20 * 60, isOneTime: true, category: "boss", warningSound: defaultWarningSound, eventSound: defaultEventNowSound },
                { name: "Наступление Ночи", type: "night_cycle", firstSpawn: 4 * 60, interval: 8 * 60, category: "cycle", warningSound: defaultWarningSound, eventSound: defaultEventNowSound },
                { name: "Наступление Дня", type: "day_cycle", firstSpawn: 8 * 60, interval: 8 * 60, category: "cycle", warningSound: defaultWarningSound, eventSound: defaultEventNowSound },
            ];
        }
        function initializeEventStates(currentTime = 0) { /* Без изменений от v4 */
            const baseDefinitions = getBaseEventDefinitions();
            eventStates = baseDefinitions.map(def => {
                const event = { ...def };
                if (event.isOneTime) {
                    event.alertedWarning = (currentTime >= event.spawnTime - ALERT_OFFSET_SECONDS && currentTime < event.spawnTime);
                    event.alertedEvent = (currentTime >= event.spawnTime);
                } else if (event.spawnTimes) {
                    event.alertedWarning = event.spawnTimes.map(st => currentTime >= st - ALERT_OFFSET_SECONDS && currentTime < st);
                    event.alertedEvent = event.spawnTimes.map(st => currentTime >= st);
                } else {
                    event.nextSpawnTime = event.firstSpawn;
                    while (event.nextSpawnTime <= currentTime) {
                        event.nextSpawnTime += event.interval;
                    }
                    event.alertedWarning = (currentTime >= event.nextSpawnTime - ALERT_OFFSET_SECONDS && currentTime < event.nextSpawnTime);
                    event.alertedEvent = false; 
                }
                return event;
            });
        }
        function rebuildPastEventsLog(currentTime) { /* Без изменений от v4 */
            pastEventsLog = [];
            const baseDefinitions = getBaseEventDefinitions();
            baseDefinitions.forEach(def => {
                if (def.isOneTime) {
                    if (def.spawnTime <= currentTime) {
                        pastEventsLog.push({ name: def.name, time: formatTime(def.spawnTime), rawTime: def.spawnTime });
                    }
                } else if (def.spawnTimes) {
                    def.spawnTimes.forEach(st => {
                        if (st <= currentTime) {
                            pastEventsLog.push({ name: `${def.name} (${formatTime(st)})`, time: formatTime(st), rawTime: st });
                        }
                    });
                } else { 
                    let currentSpawn = def.firstSpawn;
                    while (currentSpawn <= currentTime) {
                        pastEventsLog.push({ name: def.name, time: formatTime(currentSpawn), rawTime: currentSpawn });
                        currentSpawn += def.interval;
                    }
                }
            });
            pastEventsLog.sort((a, b) => b.rawTime - a.rawTime); 
            if (pastEventsLog.length > 50) pastEventsLog = pastEventsLog.slice(0, 50);
            updatePastEventsLogDisplay();
        }
        function formatTime(totalSeconds) { /* Без изменений */
            if (isNaN(totalSeconds) || totalSeconds < 0) totalSeconds = 0;
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }
        function updateTimerDisplay() { /* Без изменений */
             timerDisplay.textContent = formatTime(gameTimeInSeconds);
        }
        function playSound(player, eventNameForLog) { /* Без изменений */
            player.play().catch(error => console.error(`Audio play failed for ${eventNameForLog}:`, error));
        }
        function updatePastEventsLogDisplay() { /* Без изменений */
            pastEventsLogList.innerHTML = '';
            pastEventsLog.forEach(logEntry => {
                const listItem = document.createElement('li');
                listItem.innerHTML = `<span class="event-name">${logEntry.name}</span> <span class="log-time">(${logEntry.time})</span>`;
                pastEventsLogList.appendChild(listItem);
            });
             if(pastEventsLog.length === 0) {
                pastEventsLogList.innerHTML = '<li>Лог событий пуст.</li>';
            }
        }

        function checkAndTriggerAlerts() { // Добавлено добавление в allPotentiallyRecentEvents
            eventStates.forEach(event => {
                let eventTime, eventBaseName, uniqueEventIdPart; // eventDisplayName renamed to eventBaseName

                if (event.isOneTime) {
                    if (event.alertedEvent) return;
                    eventTime = event.spawnTime;
                    eventBaseName = event.name;
                    uniqueEventIdPart = eventTime;
                } else if (event.spawnTimes) {
                    // Обрабатываем каждый спавн отдельно
                    event.spawnTimes.forEach((spawnTime, index) => {
                        if (event.alertedEvent[index]) return;
                        eventTime = spawnTime;
                        eventBaseName = event.name; // Используем базовое имя
                        uniqueEventIdPart = spawnTime;

                        if (!event.alertedWarning[index] && gameTimeInSeconds >= eventTime - ALERT_OFFSET_SECONDS && gameTimeInSeconds < eventTime) {
                            playSound(warningSoundPlayer, `${eventBaseName} @${formatTime(eventTime)} Warning`);
                            showBrowserNotification(`Предупреждение: ${eventBaseName}`, `Через ${ALERT_OFFSET_SECONDS} сек. (в ${formatTime(eventTime)})`, `d2timer-${event.type}-${uniqueEventIdPart}-warn`, false);
                            event.alertedWarning[index] = true;
                        }
                        if (!event.alertedEvent[index] && gameTimeInSeconds >= eventTime) {
                            playSound(eventNowSoundPlayer, `${eventBaseName} @${formatTime(eventTime)} Event Now`);
                            showBrowserNotification(`${eventBaseName} СЕЙЧАС!`, `Событие началось в ${formatTime(eventTime)}`, `d2timer-${event.type}-${uniqueEventIdPart}-now`, true);
                            
                            const logName = `${eventBaseName} (${formatTime(eventTime)})`;
                            if (!pastEventsLog.find(e => e.rawTime === eventTime && e.name === logName)) {
                                 rebuildPastEventsLog(gameTimeInSeconds);
                            }
                            // Add to dynamic recent events
                            const eventId = `dyn-${event.type}-${uniqueEventIdPart}`;
                            if (!allPotentiallyRecentEvents.find(e => e.id === eventId)) {
                                allPotentiallyRecentEvents.unshift({ id: eventId, name: eventBaseName, timeText: formatTime(eventTime), occurrenceTime: eventTime });
                            }

                            event.alertedEvent[index] = true;
                        }
                    });
                    return; // Завершаем обработку для этого типа события, т.к. внутренний цикл все сделал
                } else { // Repeating
                    eventTime = event.nextSpawnTime;
                    eventBaseName = event.name;
                    uniqueEventIdPart = eventTime; // For repeating, nextSpawnTime is the unique part for this instance
                }
                // Общая логика для isOneTime и repeating (кроме spawnTimes)
                if (!event.alertedWarning && gameTimeInSeconds >= eventTime - ALERT_OFFSET_SECONDS && gameTimeInSeconds < eventTime) {
                    playSound(warningSoundPlayer, `${eventBaseName} Warning`);
                    showBrowserNotification(`Предупреждение: ${eventBaseName}`, `Через ${ALERT_OFFSET_SECONDS} сек. (в ${formatTime(eventTime)})`, `d2timer-${event.type}-${uniqueEventIdPart}-warn`, false);
                    event.alertedWarning = true;
                }
                if (gameTimeInSeconds >= eventTime) { // Событие наступило или прошло
                    if (!event.alertedEvent) { 
                       playSound(eventNowSoundPlayer, `${eventBaseName} Event Now`);
                       showBrowserNotification(`${eventBaseName} СЕЙЧАС!`, `Событие началось в ${formatTime(eventTime)}`, `d2timer-${event.type}-${uniqueEventIdPart}-now`, true);
                        if (!pastEventsLog.find(e => e.rawTime === eventTime && e.name === eventBaseName)) {
                            rebuildPastEventsLog(gameTimeInSeconds); 
                        }
                        // Add to dynamic recent events
                        const eventId = `dyn-${event.type}-${uniqueEventIdPart}`;
                         if (!allPotentiallyRecentEvents.find(e => e.id === eventId)) {
                            allPotentiallyRecentEvents.unshift({ id: eventId, name: eventBaseName, timeText: formatTime(eventTime), occurrenceTime: eventTime });
                        }
                       event.alertedEvent = true; 
                    }
                    if (!event.isOneTime && !event.spawnTimes) { // Только для повторяющихся
                        const previousNextSpawnTime = event.nextSpawnTime;
                        while(event.nextSpawnTime <= gameTimeInSeconds) { 
                            event.nextSpawnTime += event.interval;
                        }
                        if (event.nextSpawnTime > previousNextSpawnTime) {
                             event.alertedWarning = false;
                             event.alertedEvent = false;
                        }
                    }
                }
            });
            // Ограничение общего списка потенциально недавних событий
            if (allPotentiallyRecentEvents.length > 20) { // Держим буфер побольше, чем 3
                allPotentiallyRecentEvents = allPotentiallyRecentEvents.slice(0, 20);
            }
            updateUpcomingEventsDisplay();
            updateDynamicRecentEventsDisplay(); // Обновляем динамический список
        }
        
        function updateUpcomingEventsDisplay() { /* почти без изменений, но проверим логику с alertedEvent */
            const upcoming = [];
            const displayLimitFutureSeconds = gameTimeInSeconds + 15 * 60;
            eventStates.forEach(event => {
                if (event.isOneTime && !event.alertedEvent) { // Убрали gameTimeInSeconds < event.spawnTime, т.к. alertedEvent это покрывает
                    if (event.spawnTime <= displayLimitFutureSeconds && event.spawnTime > gameTimeInSeconds) { // Добавили spawnTime > gameTimeInSeconds
                        upcoming.push({ name: event.name, time: event.spawnTime, eventObj: event });
                    }
                } else if (event.spawnTimes) {
                     event.spawnTimes.forEach((spawnTime, index) => {
                        if (!event.alertedEvent[index] && spawnTime <= displayLimitFutureSeconds && spawnTime > gameTimeInSeconds) {
                             upcoming.push({ name: `${event.name}`, time: spawnTime, eventObj: event, spawnIndex: index });
                        }
                    });
                } else if (!event.isOneTime && !event.spawnTimes) { // Repeating
                    // Для повторяющихся, alertedEvent сбрасывается когда nextSpawnTime обновляется.
                    // Мы хотим видеть текущий nextSpawnTime если он еще не "случился" (т.е. gameTimeInSeconds < event.nextSpawnTime)
                    if (event.nextSpawnTime <= displayLimitFutureSeconds && gameTimeInSeconds < event.nextSpawnTime) {
                        upcoming.push({ name: event.name, time: event.nextSpawnTime, eventObj: event });
                    }
                }
            });
            upcoming.sort((a, b) => a.time - b.time);
            eventsList.innerHTML = '';
            const maxEventsToShow = 7;
            upcoming.slice(0, maxEventsToShow).forEach(e => {
                const listItem = document.createElement('li');
                const timeToSpawn = e.time - gameTimeInSeconds;
                let progressBarHtml = '';
                if (timeToSpawn <= PROGRESS_WINDOW_SECONDS && timeToSpawn > 0) {
                    const elapsedInWindow = PROGRESS_WINDOW_SECONDS - timeToSpawn;
                    const progressPercent = Math.min(100, Math.max(0, (elapsedInWindow / PROGRESS_WINDOW_SECONDS) * 100));
                    progressBarHtml = `<div class="progress-bar-container"><div class="progress-bar" style="width: ${progressPercent}%;"></div></div>`;
                }
                listItem.innerHTML = `<div class="event-details"><span class="event-name">${e.name}</span><span class="event-time">через ${formatTime(timeToSpawn)} (в ${formatTime(e.time)})</span></div>${progressBarHtml}`;
                let isWarningActive = false;
                if (e.eventObj.isOneTime) isWarningActive = e.eventObj.alertedWarning;
                else if (e.eventObj.spawnTimes) isWarningActive = e.eventObj.alertedWarning[e.spawnIndex];
                else isWarningActive = e.eventObj.alertedWarning;
                if (timeToSpawn <= 0 && timeToSpawn > -ALERT_OFFSET_SECONDS) listItem.classList.add('alert-event-now');
                else if (isWarningActive && timeToSpawn > 0 && timeToSpawn <= ALERT_OFFSET_SECONDS) listItem.classList.add('alert-warning');
                eventsList.appendChild(listItem);
            });
            if (upcoming.length === 0 && isTimerRunning) eventsList.innerHTML = '<li>Нет ожидаемых событий в ближайшее время.</li>';
            else if (!isTimerRunning && upcoming.length === 0) eventsList.innerHTML = '<li>Нет ожидаемых событий. Запустите или синхронизируйте таймер.</li>';
            else if (!isTimerRunning && gameTimeInSeconds === 0) eventsList.innerHTML = '<li>Таймер не запущен.</li>';
        }

        function mainLoop() { /* почти без изменений, но вызываем updateDynamicRecentEventsDisplay */
            if (!isTimerRunning) return;
            gameTimeInSeconds++;
            updateTimerDisplay();
            checkAndTriggerAlerts(); // Это также вызовет updateDynamicRecentEventsDisplay внутри себя
        }
        function attemptInitialSoundUnlock() { /* Без изменений */
            const p1 = warningSoundPlayer.play(); if (p1) p1.then(_=>warningSoundPlayer.pause()).catch(()=>{});
            const p2 = eventNowSoundPlayer.play(); if (p2) p2.then(_=>eventNowSoundPlayer.pause()).catch(()=>{});
        }
        startButton.addEventListener('click', async () => { /* Без изменений */ 
            attemptInitialSoundUnlock();
            if (!isTimerRunning) {
                isTimerRunning = true;
                await requestWakeLock(); 
                 if (gameTimeInSeconds === 0 && pastEventsLog.length === 0) { 
                    initializeEventStates(0);
                    rebuildPastEventsLog(0);
                    allPotentiallyRecentEvents = []; // Очищаем при полном старте
                }
                updateAllDisplays();
                timerInterval = setInterval(mainLoop, 1000);
                startButton.textContent = "Pause Timer";
            } else {
                isTimerRunning = false;
                await releaseWakeLock(); 
                clearInterval(timerInterval);
                startButton.textContent = "Resume Timer";
            }
        });
        resetButton.addEventListener('click', async () => { /* Добавлена очистка allPotentiallyRecentEvents */
            attemptInitialSoundUnlock();
            isTimerRunning = false;
            await releaseWakeLock(); 
            clearInterval(timerInterval);
            gameTimeInSeconds = 0;
            syncMinutesInput.value = ''; syncSecondsInput.value = '';
            initializeEventStates(0);
            rebuildPastEventsLog(0);
            allPotentiallyRecentEvents = []; // Очищаем при сбросе
            updateAllDisplays();
            startButton.textContent = "Start Timer";
        });
        syncButton.addEventListener('click', async () => { /* Добавлена очистка allPotentiallyRecentEvents */
            attemptInitialSoundUnlock();
            let wasTimerRunningBeforeSyncOp = isTimerRunning; 
            if (isTimerRunning) { isTimerRunning = false; clearInterval(timerInterval); }
            const minutes = parseInt(syncMinutesInput.value) || 0;
            const seconds = parseInt(syncSecondsInput.value) || 0;
            if (minutes < 0 || seconds < 0 || seconds > 59) {
                alert("Пожалуйста, введите корректное время.");
                if (wasTimerRunningBeforeSyncOp) { isTimerRunning = true; timerInterval = setInterval(mainLoop, 1000); } 
                return;
            }
            await releaseWakeLock(); 
            gameTimeInSeconds = (minutes * 60) + seconds;
            initializeEventStates(gameTimeInSeconds);
            rebuildPastEventsLog(gameTimeInSeconds);
            // Перестроить allPotentiallyRecentEvents на основе нового времени
            allPotentiallyRecentEvents = [];
            const baseDefs = getBaseEventDefinitions();
            baseDefs.forEach(def => {
                if (def.isOneTime) {
                    if (def.spawnTime <= gameTimeInSeconds && def.spawnTime + DYNAMIC_EVENT_LIFETIME_SECONDS > gameTimeInSeconds) {
                         allPotentiallyRecentEvents.unshift({ id: `dyn-${def.type}-${def.spawnTime}`, name: def.name, timeText: formatTime(def.spawnTime), occurrenceTime: def.spawnTime });
                    }
                } else if (def.spawnTimes) {
                    def.spawnTimes.forEach(st => {
                        if (st <= gameTimeInSeconds && st + DYNAMIC_EVENT_LIFETIME_SECONDS > gameTimeInSeconds) {
                             allPotentiallyRecentEvents.unshift({ id: `dyn-${def.type}-${st}`, name: def.name, timeText: formatTime(st), occurrenceTime: st });
                        }
                    });
                } else { // Repeating
                    let ts = def.firstSpawn;
                    while (ts <= gameTimeInSeconds) {
                        if (ts + DYNAMIC_EVENT_LIFETIME_SECONDS > gameTimeInSeconds) {
                             allPotentiallyRecentEvents.unshift({ id: `dyn-${def.type}-${ts}`, name: def.name, timeText: formatTime(ts), occurrenceTime: ts });
                        }
                        ts += def.interval;
                    }
                }
            });
            allPotentiallyRecentEvents.sort((a,b) => b.occurrenceTime - a.occurrenceTime);
            if(allPotentiallyRecentEvents.length > 20) allPotentiallyRecentEvents.slice(0,20);


            updateAllDisplays();
            startButton.textContent = "Resume Timer"; 
        });
        
        function updateAllDisplays() {
            updateTimerDisplay();
            updateUpcomingEventsDisplay();
            updatePastEventsLogDisplay();
            updateDynamicRecentEventsDisplay(); // Добавлено обновление динамического списка
        }

        // Initial setup
        initializeEventStates(0);
        updateAllDisplays();
        updateNotificationButtonText();
    </script>
</body>
</html>
