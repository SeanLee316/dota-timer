<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Dota 2 Таймер (Offline Ready)</title>
    <link rel="manifest" href="manifest.json"> <style>
        /* --- ОБЩИЕ СТИЛИ --- */
        :root {
            --bg-color: #1c1c1e;
            --panel-bg-color: #2a2a2a;
            --text-color: #e0e0e0;
            --accent-color: #00aeff;
            --accent-hover-color: #007acc;
            --warning-color: #ffc107;
            --event-now-color: #dc3545;
            --positive-color: #5cb85c;
            --positive-hover-color: #4cae4c;
            --exit-button-bg: rgba(220, 53, 69, 0.8);
            --exit-button-hover-bg: rgba(200, 30, 40, 1);
        }
        html, body {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; 
            background-color: var(--bg-color); color: var(--text-color);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            font-size: 14px;
            -webkit-tap-highlight-color: transparent; /* Убрать синюю подсветку при тапе на мобильных */
        }
        .app-wrapper {
            display: flex; flex-direction: column; align-items: center;
            width: 100%; height: 100%; padding: 10px;
            box-sizing: border-box; overflow-y: auto;
        }
        .main-container {
            display: flex; flex-direction: row; width: 100%;
            max-width: 1300px; gap: 15px; flex-grow: 1; min-height: 0;
        }
        .left-panel, .right-panel {
            display: flex; flex-direction: column; min-width: 0; overflow: hidden;
        }
        .left-panel { flex: 2.5; align-items: center; }
        .right-panel {
            flex: 1.5; background-color: var(--panel-bg-color);
            padding: 10px 12px; border-radius: 8px; overflow-y: auto;
        }
        #timerDisplay {
            font-size: 3.2em; margin-bottom: 8px; color: var(--accent-color);
            font-weight: bold; text-shadow: 0 0 5px rgba(0,174,255,0.5);
            text-align: center;
        }
        .controls-column {
            display: flex; flex-direction: column; align-items: center;
            gap: 8px; margin-bottom: 12px; width: 100%;
        }
        .control-group {
            display: flex; align-items: center; gap: 8px;
            background-color: var(--panel-bg-color);
            padding: 8px; border-radius: 5px;
            flex-wrap: wrap; justify-content: center;
            width: calc(100% - 16px); box-sizing: border-box;
        }
        .control-group input[type="number"] {
            width: 45px; padding: 7px; font-size: 0.95em; text-align: center;
            border: 1px solid #444; background-color: #333; color: var(--text-color);
            border-radius: 3px; -moz-appearance: textfield;
        }
        .control-group input[type="number"]::-webkit-outer-spin-button,
        .control-group input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none; margin: 0;
        }
        .control-group span { font-size: 1.1em; color: var(--accent-color); }
        .control-group button {
            font-size: 0.95em; padding: 7px 12px; cursor: pointer;
            border: none; border-radius: 5px; color: #ffffff;
            transition: background-color 0.2s ease-in-out;
        }
        .main-controls button, #lockScreenToggle { background-color: var(--accent-color); }
        .main-controls button:hover, #lockScreenToggle:hover { background-color: var(--accent-hover-color); }
        .time-sync-controls button { background-color: var(--positive-color); }
        .time-sync-controls button:hover { background-color: var(--positive-hover-color); }
        .notification-controls button { background-color: var(--warning-color); color: #1e1e1e; }
        .notification-controls button:hover { background-color: #e0a800; }

        .section-title {
            text-align: center; color: var(--accent-color);
            font-size: 1.4em; margin-bottom: 8px;
        }
        #upcomingEvents { width:100%; max-width: 600px; overflow-y: auto; flex-shrink: 1; }
        #upcomingEvents ul, #pastEventsLog ul, #dynamicRecentEventsList ul {
            list-style: none; padding: 0; margin:0;
        }
        #upcomingEvents li, #pastEventsLog li, #dynamicRecentEventsList li {
            background-color: #333333; padding: 8px 10px; margin-bottom: 6px;
            border-radius: 4px; font-size: 1em; 
            border-left: 3px solid var(--accent-color);
        }
        #pastEventsLog li { border-left-color: var(--positive-color); font-size: 0.9em; }
        #upcomingEvents li .event-details {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 4px;
        }
        .event-name { font-weight: bold; }
        .event-time, .log-time { color: #b0b0b0; font-size:0.95em; }
        .progress-bar-container {
            height: 10px; background-color: #555; border-radius: 5px;
            overflow: hidden; margin-top: 5px;
        }
        .progress-bar {
            height: 100%; background-color: var(--accent-color); width: 0%;
            transition: width 0.5s linear;
        }
        .alert-warning { border-left-color: var(--warning-color) !important; }
        .alert-event-now {
            border-left-color: var(--event-now-color) !important;
            animation: pulse 0.8s infinite alternate;
        }
        @keyframes pulse {
            0% { background-color: rgba(220, 53, 69, 0.4); }
            100% { background-color: rgba(220, 53, 69, 0.15); }
        }
        .right-panel::-webkit-scrollbar { width: 6px; }
        .right-panel::-webkit-scrollbar-track { background: var(--panel-bg-color); border-radius: 6px; }
        .right-panel::-webkit-scrollbar-thumb { background: #555; border-radius: 6px; }
        .right-panel::-webkit-scrollbar-thumb:hover { background: #777; }
        .status-messages {
            font-size: 0.8em; color: #aaa; margin-top: 4px;
            text-align: center; min-height: 1em; width: 100%;
        }
        #dynamicRecentEventsContainer {
            display: none; 
            width: calc(100% - 16px); margin-top: 10px; padding: 8px;
            background-color: #272729; border-radius: 5px; box-sizing: border-box;
            overflow-y: auto; flex-shrink: 0; 
        }
        #dynamicRecentEventsContainer .section-title { font-size: 1.1em; margin-bottom: 6px; }
        #dynamicRecentEventsList li {
            background-color: #38383a; padding: 6px 8px; font-size: 0.9em;
            display: flex; justify-content: space-between; align-items: center;
            border-left: 3px solid #ff9800;
        }
        #dynamicRecentEventsList .event-name { font-weight: normal; }
        #dynamicRecentEventsList .event-meta { font-size: 0.85em; color: #c0c0c0; }
        #dynamicRecentEventsList .event-timeout { font-size: 0.8em; color: #999; margin-left: 8px;}

        /* --- АДАПТАЦИЯ (ОБЫЧНЫЙ РЕЖИМ) --- */
        @media (max-width: 768px) and (orientation: portrait) {
            .app-wrapper { padding: 5px; }
            .main-container { flex-direction: column; gap: 10px; }
            .left-panel, .right-panel { flex-basis: auto; width: 100%; }
            .right-panel { max-height: 30vh; }
            #dynamicRecentEventsContainer { display: none !important; } 
        }
        @media (max-height: 550px) and (orientation: landscape) and (max-width: 900px) { 
            .app-wrapper { padding: 5px; }
            body:not(.horizontal-lockscreen-mode) { font-size: 12.5px; }
            .main-container { gap: 8px; }
            .left-panel { flex: 3; }
            .right-panel { flex: 1.8; font-size: 0.8em; padding: 8px; }
            #timerDisplay { font-size: 2.8em; }
            .control-group button { font-size: 0.85em; padding: 5px 8px; margin: 3px; }
            .control-group input[type="number"] { width: 38px; padding: 5px; font-size: 0.85em;}
            .section-title { font-size: 1.2em; }
            #upcomingEvents li { padding: 6px 8px; font-size: 0.95em; }
            #dynamicRecentEventsContainer { display: block; order: 3; }
            .right-panel { max-height: calc(100vh - 20px); }
        }
        @media (min-width: 769px) and (max-width: 1024px) and (orientation: landscape) {
            body:not(.horizontal-lockscreen-mode) { font-size: 13.5px; }
            .left-panel { flex: 2.2; }
            .right-panel { flex: 1.8; }
            #dynamicRecentEventsContainer { display: none; } 
        }

        /* --- LOCKSCREEN РЕЖИМ --- */
        body.horizontal-lockscreen-mode { font-size: 16px; } /* Базовый для LockScreen */
        body.horizontal-lockscreen-mode .app-wrapper {
            padding: 0; overflow: hidden; 
        }
        body.horizontal-lockscreen-mode .main-container {
            flex-direction: column; height: 100%; width: 100%;
            padding: 1.5vh 2vw; gap: 1vh; 
            justify-content: space-between; box-sizing: border-box;
            background-color: #000; 
        }
        body.horizontal-lockscreen-mode .controls-column,
        body.horizontal-lockscreen-mode .right-panel, 
        body.horizontal-lockscreen-mode #wakeLockStatus,
        body.horizontal-lockscreen-mode #notificationStatus,
        body.horizontal-lockscreen-mode #upcomingEvents > .section-title,
        body.horizontal-lockscreen-mode #lockScreenToggle { 
            display: none !important;
        }
        body.horizontal-lockscreen-mode .left-panel {
            flex: 1; width: 100%;
            justify-content: flex-start; align-items: center;
            overflow: hidden; gap: 1.5vh; 
        }
        body.horizontal-lockscreen-mode #timerDisplay {
            font-size: min(9vh, 10vw); /* УМЕНЬШЕНО, но все еще крупно */
            line-height: 1; margin-bottom: 0.5vh; /* Меньше отступ */
            flex-shrink: 0; 
        }
        body.horizontal-lockscreen-mode #upcomingEvents {
            width: 100%; max-width: none; flex-grow: 1;
            overflow-y: hidden; 
            display: flex; flex-direction: column; justify-content: space-around;
            max-height: 48vh; /* Скорректировано для баланса с недавними */
        }
        body.horizontal-lockscreen-mode #upcomingEvents ul {
            display: flex; flex-direction: column; height: 100%;
            justify-content: space-around; 
        }
        body.horizontal-lockscreen-mode #upcomingEvents li {
            padding: 1.5vh 2vw; font-size: min(3.4vh, 3.2vw); 
            border-left-width: 5px; flex-grow: 1; margin-bottom: 1vh; 
            display: flex; flex-direction: column; justify-content: center;
        }
        body.horizontal-lockscreen-mode #upcomingEvents li:last-child { margin-bottom: 0; }
        body.horizontal-lockscreen-mode #upcomingEvents li .event-details {
             flex-direction: column; align-items: flex-start; gap: 0.5vh;
        }
        body.horizontal-lockscreen-mode #upcomingEvents li .event-name { font-size: 1em; }
        body.horizontal-lockscreen-mode #upcomingEvents li .event-time { font-size: 0.8em; }
        body.horizontal-lockscreen-mode #upcomingEvents li .progress-bar-container {
            height: 2.2vh; border-radius: 1.1vh; margin-top: 1vh;
        }
        body.horizontal-lockscreen-mode #dynamicRecentEventsContainer {
            display: block !important; width: 100%;
            padding: 1.8vh 1.8vw; /* УВЕЛИЧЕНЫ отступы */
            font-size: min(3.5vh, 3.2vw); /* УВЕЛИЧЕН шрифт */
            background-color: #181818; border-top: 1px solid #444;
            flex-shrink: 0; max-height: 35vh; /* УВЕЛИЧЕНО */
            overflow-y: auto;
        }
        body.horizontal-lockscreen-mode #dynamicRecentEventsContainer .section-title {
            display: block; font-size: 0.8em; margin-bottom: 0.8vh; color: #ddd;
        }
        body.horizontal-lockscreen-mode #dynamicRecentEventsList li {
            padding: 1.2vh 1.5vw; /* УВЕЛИЧЕНО */
            font-size: 1em; background-color: #282828; margin-bottom: 1vh;
        }
        body.horizontal-lockscreen-mode #dynamicRecentEventsList .event-meta {
            font-size: 0.9em; 
        }
        body.horizontal-lockscreen-mode #dynamicRecentEventsList .event-timeout { 
            display: inline; font-size: 0.85em; 
        }
        
        #exitLockScreenButton { 
            display: none; position: fixed; 
            top: 15px; right: 15px; z-index: 20000; 
            padding: 0; /* Убираем padding для точного размера */
            background-color: var(--exit-button-bg); color: white; 
            border: none; border-radius: 50%; 
            font-size: 1.5em; /* Размер иконки */
            width: 45px; height: 45px;
            line-height: 45px; /* Центрируем иконку */
            text-align: center;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            cursor: pointer;
            user-select: none; /* Предотвратить выделение текста на кнопке */
        }
        #exitLockScreenButton:hover {
            background-color: var(--exit-button-hover-bg);
        }
    </style>
</head>
<body>
    <div class="app-wrapper">
        <div class="main-container">
            <div class="left-panel">
                <div id="timerDisplay">00:00</div>
                <div class="controls-column">
                    <div class="control-group time-sync-controls">
                        <input type="number" id="syncMinutes" placeholder="MM" min="0">
                        <span>:</span>
                        <input type="number" id="syncSeconds" placeholder="SS" min="0" max="59">
                        <button id="syncButton">Синхронизировать</button>
                    </div>
                    <div class="control-group main-controls">
                        <button id="startButton">Start Timer</button>
                        <button id="resetButton">Reset Timer</button>
                        <button id="lockScreenToggle">📱 Горизонт. Режим</button>
                    </div>
                    <div class="control-group notification-controls">
                        <button id="toggleNotificationsButton">Включить Уведомления</button>
                    </div>
                </div>
                 <div id="wakeLockStatus" class="status-messages"></div>
                 <div id="notificationStatus" class="status-messages"></div>

                <div id="upcomingEvents" style="width:100%; max-width:600px;">
                    <h2 class="section-title">Ближайшие события</h2>
                    <ul id="eventsList"></ul>
                </div>
                <div id="dynamicRecentEventsContainer">
                    <h2 class="section-title">Недавние Активности</h2>
                    <ul id="dynamicRecentEventsList"></ul>
                </div>
            </div>
            <div class="right-panel">
                <h2 class="section-title">Полный Лог</h2>
                <ul id="pastEventsLogList"></ul>
            </div>
        </div>
    </div>
    <button id="exitLockScreenButton" title="Выйти из полноэкранного режима">✖</button> 


    <audio id="warningSoundPlayer" src="warning_alert.mp3" preload="auto"></audio>
    <audio id="eventNowSoundPlayer" src="event_now_alert.mp3" preload="auto"></audio>

    <script>
        // --- DOM Element References ---
        const timerDisplay = document.getElementById('timerDisplay');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');
        const lockScreenToggleButton = document.getElementById('lockScreenToggle');
        const exitLockScreenButton = document.getElementById('exitLockScreenButton');
        const syncMinutesInput = document.getElementById('syncMinutes');
        const syncSecondsInput = document.getElementById('syncSeconds');
        const syncButton = document.getElementById('syncButton');
        const toggleNotificationsButton = document.getElementById('toggleNotificationsButton');
        const eventsList = document.getElementById('eventsList');
        const dynamicRecentEventsList = document.getElementById('dynamicRecentEventsList');
        const pastEventsLogList = document.getElementById('pastEventsLogList');
        const warningSoundPlayer = document.getElementById('warningSoundPlayer');
        const eventNowSoundPlayer = document.getElementById('eventNowSoundPlayer');
        const wakeLockStatus = document.getElementById('wakeLockStatus');
        const notificationStatus = document.getElementById('notificationStatus');

        // --- Constants ---
        const ALERT_OFFSET_SECONDS = 15;
        const PROGRESS_WINDOW_SECONDS = 120;
        const DOTA_ICON_PATH = 'dota_icon.png'; 
        const DYNAMIC_EVENT_LIFETIME_SECONDS = 45; 

        // --- State Variables ---
        let gameTimeInSeconds = 0;
        let timerInterval = null;
        let isTimerRunning = false;
        let eventStates = [];
        let pastEventsLog = [];
        let allPotentiallyRecentEvents = [];
        let wakeLockSentinel = null;
        let popUpNotificationsEnabled = false;

        // --- Screen Wake Lock Functions ---
        const requestWakeLock = async () => {
            if ('wakeLock' in navigator) {
                try {
                    if (wakeLockSentinel) { await wakeLockSentinel.release(); wakeLockSentinel = null; }
                    wakeLockSentinel = await navigator.wakeLock.request('screen');
                    wakeLockStatus.textContent = 'Экран не будет гаснуть.';
                    wakeLockSentinel.addEventListener('release', (event) => { // Добавлен параметр event
                        wakeLockStatus.textContent = '';
                        if (event && event.target === wakeLockSentinel) wakeLockSentinel = null;
                        else if (!event) wakeLockSentinel = null; // На случай если event не передан
                    });
                } catch (err) {
                    console.error("Wake Lock request error:", err);
                    wakeLockStatus.textContent = 'Не удалось удержать экран.'; wakeLockSentinel = null;
                }
            } else { wakeLockStatus.textContent = 'API удержания экрана не поддерживается.'; }
        };
        const releaseWakeLock = async () => {
            if (wakeLockSentinel) {
                try { await wakeLockSentinel.release(); } catch (err) { console.error("Wake Lock release error:", err); }
                finally { wakeLockSentinel = null; wakeLockStatus.textContent = ''; }
            }
        };
        document.addEventListener('visibilitychange', async () => {
            if (document.visibilityState === 'visible' && isTimerRunning && !wakeLockSentinel) {
                await requestWakeLock();
            }
        });

        // --- Notification Functions ---
        function updateNotificationButtonText() {
            if (Notification.permission === 'denied') {
                toggleNotificationsButton.textContent = 'Уведомления Заблокированы';
                toggleNotificationsButton.disabled = true;
                notificationStatus.textContent = 'Вы заблокировали уведомления для этого сайта.';
            } else if (popUpNotificationsEnabled && Notification.permission === 'granted') {
                toggleNotificationsButton.textContent = 'Выключить Уведомления';
                notificationStatus.textContent = 'Всплывающие уведомления включены.';
            } else {
                toggleNotificationsButton.textContent = 'Включить Уведомления';
                 notificationStatus.textContent = Notification.permission === 'granted' ? 'Всплывающие уведомления выключены.' : 'Разрешите уведомления для сайта.';
            }
        }
        toggleNotificationsButton.addEventListener('click', () => {
            if (Notification.permission === 'denied') { return; }
            if (Notification.permission === 'granted') {
                popUpNotificationsEnabled = !popUpNotificationsEnabled;
                updateNotificationButtonText();
            } else if (Notification.permission === 'default') {
                Notification.requestPermission().then(permission => {
                    if (permission === 'granted') popUpNotificationsEnabled = true;
                    updateNotificationButtonText();
                }).catch(err => { console.error("Notification permission request error:", err); updateNotificationButtonText(); });
            }
        });
        function showBrowserNotification(title, body, tag, requireInteraction = false) {
            if (!popUpNotificationsEnabled || Notification.permission !== 'granted' || (!document.hasFocus() && !document.body.classList.contains('horizontal-lockscreen-mode'))) {
                // В LockScreen режиме уведомления показываем всегда, если разрешены
                // В обычном режиме - только если вкладка активна (можно изменить это условие)
                 if (!document.body.classList.contains('horizontal-lockscreen-mode') && !document.hasFocus()) return;
                 if (!popUpNotificationsEnabled || Notification.permission !== 'granted') return;
            }
            const options = { body, icon: DOTA_ICON_PATH, tag, renotify: true, requireInteraction };
            try { new Notification(title, options); } catch (e) { console.error("Error showing notification: ", e); }
        }

        // --- Event Definitions and State Initialization ---
        function getBaseEventDefinitions() {
            const dWS = "warning_alert.mp3"; const dENS = "event_now_alert.mp3";
            return [
                { name: "Начальные Руны Богатства", type: "b_init", spawnTime: 0, isOneTime: true, cat: "rune", ws: dWS, es: dENS },
                { name: "Водные Руны", type: "water", spawnTimes: [120, 240], cat: "rune", ws: dWS, es: dENS },
                { name: "Руны Богатства", type: "bounty", firstSpawn: 180, interval: 180, cat: "rune", ws: dWS, es: dENS },
                { name: "Руны Усиления", type: "power", firstSpawn: 360, interval: 120, cat: "rune", ws: dWS, es: dENS },
                { name: "Руны Мудрости", type: "wisdom", firstSpawn: 420, interval: 420, cat: "rune", ws: dWS, es: dENS },
                { name: "Катапульты", type: "siege", firstSpawn: 300, interval: 150, cat: "creep", ws: dWS, es: dENS },
                { name: "Лотосы", type: "lotus", firstSpawn: 180, interval: 180, cat: "object", ws: dWS, es: dENS },
                { name: "Терзатель", type: "tormentor", spawnTime: 1200, isOneTime: true, cat: "boss", ws: dWS, es: dENS },
                { name: "Ночь", type: "night", firstSpawn: 240, interval: 480, cat: "cycle", ws: dWS, es: dENS },
                { name: "День", type: "day", firstSpawn: 480, interval: 480, cat: "cycle", ws: dWS, es: dENS },
            ];
        }
        function initializeEventStates(currentTime = 0) {
            const baseDefinitions = getBaseEventDefinitions();
            eventStates = baseDefinitions.map(def => {
                const event = { ...def };
                event.warningSound = event.ws; event.eventSound = event.es; 
                if (event.isOneTime) {
                    event.alertedWarning = (currentTime >= event.spawnTime - ALERT_OFFSET_SECONDS && currentTime < event.spawnTime);
                    event.alertedEvent = (currentTime >= event.spawnTime);
                } else if (event.spawnTimes) {
                    event.alertedWarning = event.spawnTimes.map(st => currentTime >= st - ALERT_OFFSET_SECONDS && currentTime < st);
                    event.alertedEvent = event.spawnTimes.map(st => currentTime >= st);
                } else { 
                    event.nextSpawnTime = event.firstSpawn;
                    while (event.nextSpawnTime <= currentTime) { event.nextSpawnTime += event.interval; }
                    event.alertedWarning = (currentTime >= event.nextSpawnTime - ALERT_OFFSET_SECONDS && currentTime < event.nextSpawnTime);
                    event.alertedEvent = false;
                }
                return event;
            });
        }

        // --- Log and Display Functions ---
        function formatTime(totalSeconds) {
            if (isNaN(totalSeconds) || totalSeconds < 0) totalSeconds = 0;
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }
        function updateTimerDisplay() { timerDisplay.textContent = formatTime(gameTimeInSeconds); }
        function playSound(player, eventNameForLog) { 
            if(player && typeof player.play === 'function') {
                player.play().catch(error => console.error(`Audio for ${eventNameForLog}:`, error));
            }
        }
        
        function rebuildPastEventsLog(currentTime) {
            pastEventsLog = [];
            getBaseEventDefinitions().forEach(def => {
                if (def.isOneTime) {
                    if (def.spawnTime <= currentTime) pastEventsLog.push({ name: def.name, time: formatTime(def.spawnTime), rawTime: def.spawnTime });
                } else if (def.spawnTimes) {
                    def.spawnTimes.forEach(st => { if (st <= currentTime) pastEventsLog.push({ name: `${def.name} (${formatTime(st)})`, time: formatTime(st), rawTime: st }); });
                } else {
                    for (let ts = def.firstSpawn; ts <= currentTime; ts += def.interval) pastEventsLog.push({ name: def.name, time: formatTime(ts), rawTime: ts });
                }
            });
            pastEventsLog.sort((a, b) => b.rawTime - a.rawTime);
            if (pastEventsLog.length > 50) pastEventsLog = pastEventsLog.slice(0, 50);
            updatePastEventsLogDisplay();
        }
        function updatePastEventsLogDisplay() {
            pastEventsLogList.innerHTML = pastEventsLog.map(log => `<li><span class="event-name">${log.name}</span> <span class="log-time">(${log.time})</span></li>`).join('');
            if (pastEventsLog.length === 0) pastEventsLogList.innerHTML = '<li>Лог событий пуст.</li>';
        }
        function updateDynamicRecentEventsDisplay() {
            const now = gameTimeInSeconds;
            let recentAndValid = allPotentiallyRecentEvents.filter(event => (event.occurrenceTime + DYNAMIC_EVENT_LIFETIME_SECONDS) > now);
            recentAndValid.sort((a, b) => b.occurrenceTime - a.occurrenceTime);
            const displayItems = recentAndValid.slice(0, 3);

            dynamicRecentEventsList.innerHTML = '';
            const containerVisible = document.getElementById('dynamicRecentEventsContainer').style.display !== 'none' || document.body.classList.contains('horizontal-lockscreen-mode');

            if (displayItems.length === 0 && containerVisible) {
                 dynamicRecentEventsList.innerHTML = '<li>Нет недавних активностей.</li>';
            } else {
                displayItems.forEach(event => {
                    const timeLeft = Math.max(0, (event.occurrenceTime + DYNAMIC_EVENT_LIFETIME_SECONDS) - now);
                    dynamicRecentEventsList.innerHTML += `<li><span class="event-name">${event.name}</span><span class="event-meta">(${event.timeText}) <span class="event-timeout">Еще ~${timeLeft}с</span></span></li>`;
                });
            }
        }
        function updateUpcomingEventsDisplay(isLockScreen = false) {
            const upcoming = [];
            const displayLimit = gameTimeInSeconds + 15 * 60;
            const maxItems = isLockScreen ? 4 : 7;

            eventStates.forEach(event => {
                if (event.isOneTime && !event.alertedEvent && event.spawnTime > gameTimeInSeconds && event.spawnTime <= displayLimit) {
                    upcoming.push({ name: event.name, time: event.spawnTime, eventObj: event });
                } else if (event.spawnTimes) {
                    event.spawnTimes.forEach((st, idx) => {
                        if (!event.alertedEvent[idx] && st > gameTimeInSeconds && st <= displayLimit) {
                            upcoming.push({ name: event.name, time: st, eventObj: event, spawnIndex: idx });
                        }
                    });
                } else if (!event.isOneTime && !event.spawnTimes && event.nextSpawnTime > gameTimeInSeconds && event.nextSpawnTime <= displayLimit) {
                    upcoming.push({ name: event.name, time: event.nextSpawnTime, eventObj: event });
                }
            });
            upcoming.sort((a, b) => a.time - b.time);
            eventsList.innerHTML = '';
            upcoming.slice(0, maxItems).forEach(e => {
                const timeTo = e.time - gameTimeInSeconds;
                const progressVal = (timeTo <= PROGRESS_WINDOW_SECONDS && timeTo > 0) ? Math.min(100, Math.max(0, ((PROGRESS_WINDOW_SECONDS - timeTo) / PROGRESS_WINDOW_SECONDS) * 100)) : 0;
                const progressHtml = progressVal > 0 ? `<div class="progress-bar-container"><div class="progress-bar" style="width: ${progressVal}%;"></div></div>` : '';
                
                let alertedWarningFlag = false;
                if(e.eventObj.isOneTime) alertedWarningFlag = e.eventObj.alertedWarning;
                else if(e.eventObj.spawnTimes) alertedWarningFlag = e.eventObj.alertedWarning[e.spawnIndex];
                else alertedWarningFlag = e.eventObj.alertedWarning;

                const classListVal = timeTo <= 0 && timeTo > -ALERT_OFFSET_SECONDS ? 'alert-event-now' : (alertedWarningFlag && timeTo > 0 && timeTo <= ALERT_OFFSET_SECONDS ? 'alert-warning' : '');
                eventsList.innerHTML += `<li class="${classListVal}"><div class="event-details"><span class="event-name">${e.name}</span><span class="event-time">через ${formatTime(timeTo)} (в ${formatTime(e.time)})</span></div>${progressHtml}</li>`;
            });
            if (upcoming.length === 0 && isTimerRunning) eventsList.innerHTML = '<li>Нет ожидаемых событий.</li>';
            else if (!isTimerRunning && upcoming.length === 0) eventsList.innerHTML = '<li>Запустите или синхронизируйте.</li>';
            else if (!isTimerRunning && gameTimeInSeconds === 0) eventsList.innerHTML = '<li>Таймер не запущен.</li>';
        }
        function updateAllDisplays() {
            updateTimerDisplay();
            updateUpcomingEventsDisplay(document.body.classList.contains('horizontal-lockscreen-mode'));
            updatePastEventsLogDisplay();
            updateDynamicRecentEventsDisplay();
        }

        // --- Core Logic: checkAndTriggerAlerts & mainLoop ---
        function checkAndTriggerAlerts() {
            eventStates.forEach(event => {
                let eventTime, baseName, uniqueIdPart;
                const processEventInstance = (currentTime, alertedWarningFlag, alertedEventFlag, setWarningFlag, setEventFlag, isRepeating = false, advanceRepeatFunc = null) => {
                    if (alertedEventFlag && !isRepeating) return; // Для не-повторяющихся, если событие уже было, выходим
                    if (isRepeating && gameTimeInSeconds < currentTime && alertedEventFlag) return; // Для повторяющихся, если текущее время еще не достигло *нового* nextSpawnTime, но флаг alertedEvent почему-то true (например, от предыдущего спавна), не обрабатываем


                    if (!alertedWarningFlag && gameTimeInSeconds >= currentTime - ALERT_OFFSET_SECONDS && gameTimeInSeconds < currentTime) {
                        playSound(warningSoundPlayer, `${baseName} Warning`);
                        showBrowserNotification(`Предупреждение: ${baseName}`, `Через ${ALERT_OFFSET_SECONDS} сек. (в ${formatTime(currentTime)})`, `d2timer-${event.type}-${uniqueIdPart}-warn`, false);
                        setWarningFlag(true);
                    }
                    if (!alertedEventFlag && gameTimeInSeconds >= currentTime) {
                        playSound(eventNowSoundPlayer, `${baseName} Event Now`);
                        showBrowserNotification(`${baseName} СЕЙЧАС!`, `Событие началось в ${formatTime(currentTime)}`, `d2timer-${event.type}-${uniqueIdPart}-now`, true);
                        
                        const logName = event.spawnTimes ? `${baseName} (${formatTime(currentTime)})` : baseName;
                        if (!pastEventsLog.find(e_1 => e_1.rawTime === currentTime && e_1.name === logName)) {
                             rebuildPastEventsLog(gameTimeInSeconds);
                        }
                        const eventId = `dyn-${event.type}-${uniqueIdPart}`;
                        if (!allPotentiallyRecentEvents.find(e_2 => e_2.id === eventId)) {
                            allPotentiallyRecentEvents.unshift({ id: eventId, name: baseName, timeText: formatTime(currentTime), occurrenceTime: currentTime });
                        }
                        setEventFlag(true); // Важно: ставим флаг, что это *конкретное* время события обработано
                        if (isRepeating && advanceRepeatFunc) advanceRepeatFunc();
                    }
                };

                if (event.isOneTime) {
                    eventTime = event.spawnTime; baseName = event.name; uniqueIdPart = eventTime;
                    processEventInstance(eventTime, event.alertedWarning, event.alertedEvent, (v) => event.alertedWarning = v, (v) => event.alertedEvent = v);
                } else if (event.spawnTimes) {
                    event.spawnTimes.forEach((st, idx) => {
                        eventTime = st; baseName = event.name; uniqueIdPart = st;
                        processEventInstance(eventTime, event.alertedWarning[idx], event.alertedEvent[idx], (v) => event.alertedWarning[idx] = v, (v) => event.alertedEvent[idx] = v);
                    });
                } else { // Repeating
                    eventTime = event.nextSpawnTime; baseName = event.name; uniqueIdPart = eventTime; // Уникальный ID для текущего nextSpawnTime
                    processEventInstance(eventTime, event.alertedWarning, event.alertedEvent, 
                        (v) => event.alertedWarning = v, 
                        (v) => event.alertedEvent = v, // Этот флаг сбросится только когда nextSpawnTime действительно продвинется
                        true, 
                        () => { // advanceRepeatFunc
                            const prevNextSpawn = event.nextSpawnTime;
                            // Продвигаем nextSpawnTime до следующего значения, которое БОЛЬШЕ текущего gameTimeInSeconds
                            while (event.nextSpawnTime <= gameTimeInSeconds) {
                                event.nextSpawnTime += event.interval;
                            }
                            // Если nextSpawnTime действительно изменился (т.е. мы перешли к следующему интервалу), сбрасываем флаги
                            if (event.nextSpawnTime > prevNextSpawn) { 
                                event.alertedWarning = false; 
                                event.alertedEvent = false;
                            }
                        }
                    );
                }
            });
            if (allPotentiallyRecentEvents.length > 20) allPotentiallyRecentEvents = allPotentiallyRecentEvents.slice(0, 20);
            updateAllDisplays();
        }
        function mainLoop() {
            if (!isTimerRunning) return;
            gameTimeInSeconds++;
            checkAndTriggerAlerts();
        }

        // --- LockScreen Mode Logic ---
        async function enterLockScreenMode() {
            document.body.classList.add('horizontal-lockscreen-mode');
            document.querySelector('.app-wrapper').scrollTop = 0;
            lockScreenToggleButton.textContent = 'Выйти';
            exitLockScreenButton.style.display = 'block';
            if (document.documentElement.requestFullscreen) {
                try { await document.documentElement.requestFullscreen(); } catch (err) { console.warn("FS fail:",err.message); }
            }
            if (screen.orientation && screen.orientation.lock) {
                try { await screen.orientation.lock('landscape'); } catch (err) { console.warn("Orient. lock fail:",err.message); }
            }
            if (isTimerRunning && !wakeLockSentinel) await requestWakeLock();
            updateAllDisplays();
        }
        async function exitLockScreenMode() {
            document.body.classList.remove('horizontal-lockscreen-mode');
            lockScreenToggleButton.textContent = '📱 Горизонт. Режим';
            exitLockScreenButton.style.display = 'none';
            if (document.fullscreenElement && document.exitFullscreen) {
                try { await document.exitFullscreen(); } catch (err) { console.warn("Exit FS fail:",err.message); }
            }
            if (screen.orientation && screen.orientation.unlock) {
                try { screen.orientation.unlock(); } catch (err) { console.warn("Orient. unlock fail:",err.message); }
            }
            updateAllDisplays();
        }
        lockScreenToggleButton.addEventListener('click', () => {
            if (document.body.classList.contains('horizontal-lockscreen-mode')) exitLockScreenMode();
            else enterLockScreenMode();
        });
        exitLockScreenButton.addEventListener('click', exitLockScreenMode);
        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement && document.body.classList.contains('horizontal-lockscreen-mode')) {
                exitLockScreenMode();
            }
        });
        
        // --- Event Listeners for Controls ---
        function attemptInitialSoundUnlock() {
            const p1 = warningSoundPlayer.play(); if (p1 && p1.then) p1.then(_=>warningSoundPlayer.pause()).catch(()=>{});
            const p2 = eventNowSoundPlayer.play(); if (p2 && p2.then) p2.then(_=>eventNowSoundPlayer.pause()).catch(()=>{});
        }
        startButton.addEventListener('click', async () => {
            attemptInitialSoundUnlock();
            if (!isTimerRunning) {
                isTimerRunning = true;
                await requestWakeLock();
                if (gameTimeInSeconds === 0 && pastEventsLog.length === 0) {
                    initializeEventStates(0); rebuildPastEventsLog(0); allPotentiallyRecentEvents = [];
                }
                updateAllDisplays(); 
                if(timerInterval) clearInterval(timerInterval); // На всякий случай, если старый интервал не был очищен
                timerInterval = setInterval(mainLoop, 1000);
                startButton.textContent = "Pause Timer";
            } else {
                isTimerRunning = false;
                await releaseWakeLock();
                clearInterval(timerInterval);
                timerInterval = null; // Явно обнуляем
                startButton.textContent = "Resume Timer";
            }
        });
        resetButton.addEventListener('click', async () => {
            attemptInitialSoundUnlock();
            isTimerRunning = false; await releaseWakeLock(); 
            if(timerInterval) clearInterval(timerInterval); timerInterval = null;
            gameTimeInSeconds = 0;
            syncMinutesInput.value = ''; syncSecondsInput.value = '';
            initializeEventStates(0); rebuildPastEventsLog(0); allPotentiallyRecentEvents = [];
            updateAllDisplays();
            startButton.textContent = "Start Timer";
        });
        syncButton.addEventListener('click', async () => {
            attemptInitialSoundUnlock();
            let wasRunning = isTimerRunning;
            if (isTimerRunning) { isTimerRunning = false; clearInterval(timerInterval); timerInterval = null; }
            
            const minutesText = syncMinutesInput.value;
            const secondsText = syncSecondsInput.value;
            const minutes = minutesText === "" ? 0 : parseInt(minutesText);
            const seconds = secondsText === "" ? 0 : parseInt(secondsText);

            if (isNaN(minutes) || isNaN(seconds) || minutes < 0 || seconds < 0 || seconds > 59) {
                alert("Пожалуйста, введите корректное время (минуты >= 0, секунды 0-59).");
                if (wasRunning) { 
                    isTimerRunning = true; 
                    if(timerInterval) clearInterval(timerInterval);
                    timerInterval = setInterval(mainLoop, 1000); 
                }
                return;
            }
            await releaseWakeLock(); 
            gameTimeInSeconds = (minutes * 60) + seconds;
            initializeEventStates(gameTimeInSeconds);
            rebuildPastEventsLog(gameTimeInSeconds);
            allPotentiallyRecentEvents = []; 
            getBaseEventDefinitions().forEach(def => {
                const addRecent = (ts, name, type) => {
                    if (ts <= gameTimeInSeconds && ts + DYNAMIC_EVENT_LIFETIME_SECONDS > gameTimeInSeconds) {
                        allPotentiallyRecentEvents.unshift({ id: `dyn-${type}-${ts}`, name, timeText: formatTime(ts), occurrenceTime: ts });
                    }
                };
                if (def.isOneTime) addRecent(def.spawnTime, def.name, def.type);
                else if (def.spawnTimes) def.spawnTimes.forEach(st => addRecent(st, def.name, def.type));
                else for (let ts = def.firstSpawn; ts <= gameTimeInSeconds; ts += def.interval) addRecent(ts, def.name, def.type);
            });
            allPotentiallyRecentEvents.sort((a,b) => b.occurrenceTime - a.occurrenceTime);
            if(allPotentiallyRecentEvents.length > 20) allPotentiallyRecentEvents = allPotentiallyRecentEvents.slice(0,20);
            updateAllDisplays();
            startButton.textContent = "Resume Timer";
        });

        // --- Service Worker Registration ---
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js') // Убедитесь, что путь к sw.js правильный
                    .then(registration => {
                        console.log('ServiceWorker registration successful with scope: ', registration.scope);
                    })
                    .catch(error => {
                        console.log('ServiceWorker registration failed: ', error);
                    });
            });
        }
        
        // --- Initial Page Load ---
        initializeEventStates(0);
        updateAllDisplays();
        updateNotificationButtonText();
    </script>
</body>
</html>
